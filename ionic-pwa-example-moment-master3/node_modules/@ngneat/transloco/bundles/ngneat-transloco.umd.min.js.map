{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@ngneat/transloco/lib/transloco.loader.ts","ng://@ngneat/transloco/lib/helpers.ts","ng://@ngneat/transloco/lib/transloco.config.ts","ng://@ngneat/transloco/lib/transloco.transpiler.ts","ng://@ngneat/transloco/lib/transloco-missing-handler.ts","ng://@ngneat/transloco/lib/transloco.interceptor.ts","ng://@ngneat/transloco/lib/transloco-fallback-strategy.ts","ng://@ngneat/transloco/lib/transloco.service.ts","ng://@ngneat/transloco/lib/shared.ts","ng://@ngneat/transloco/lib/resolve-loader.ts","ng://@ngneat/transloco/lib/get-fallbacks-loaders.ts","ng://@ngneat/transloco/lib/merge-config.ts","ng://@ngneat/transloco/lib/loader-component.component.ts","ng://@ngneat/transloco/lib/template-handler.ts","ng://@ngneat/transloco/lib/transloco-lang.ts","ng://@ngneat/transloco/lib/transloco-loading-template.ts","ng://@ngneat/transloco/lib/transloco-scope.ts","ng://@ngneat/transloco/lib/lang-resolver.ts","ng://@ngneat/transloco/lib/scope-resolver.ts","ng://@ngneat/transloco/lib/transloco.directive.ts","ng://@ngneat/transloco/lib/transloco.pipe.ts","ng://@ngneat/transloco/lib/transloco.module.ts","ng://@ngneat/transloco/lib/transloco-testing.module.ts","ng://@ngneat/transloco/lib/browser-lang.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { InjectionToken } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Translation } from './types';\n\nexport interface TranslocoLoader {\n  getTranslation(lang: string, data?: TranslocoLoaderData): Observable<Translation> | Promise<Translation>;\n}\n\nexport type TranslocoLoaderData = {\n  scope: string;\n};\n\nexport class DefaultLoader implements TranslocoLoader {\n  constructor(private translations: Map<string, Translation>) {}\n\n  getTranslation(lang: string): Observable<Translation> {\n    return of(this.translations.get(lang) || {});\n  }\n}\n\nexport const TRANSLOCO_LOADER = new InjectionToken<Translation>('TRANSLOCO_LOADER');\n","import { ProviderScope, Translation } from './types';\nimport flat from 'flat';\n\nexport function getValue(obj: object, path: string) {\n  /* For cases where the key is like: 'general.something.thing' */\n  if (obj && obj.hasOwnProperty(path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce((p, c) => p && p[c], obj);\n}\n\nexport function setValue(obj: any, prop: string, val: any) {\n  obj = { ...obj };\n\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part] };\n    }\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n}\n\nexport function size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return !!collection ? collection.length : 0;\n}\n\nexport function isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nexport function isFunction(val: any): val is Function {\n  return typeof val === 'function';\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val: any): val is number {\n  return typeof val === 'number';\n}\n\nexport function isObject(item): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nexport function coerceArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nexport function toCamelCase(str: string): string {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => (index == 0 ? word.toLowerCase() : word.toUpperCase()))\n    .replace(/\\s+|_|-|\\//g, '');\n}\n\nexport function isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nexport function isNil(value: any) {\n  return value === null || value === undefined;\n}\n\nexport function isDefined(value: any) {\n  return isNil(value) === false;\n}\n\nexport function toNumber(value: number | string): number | null {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nexport function isScopeObject(item: any): item is ProviderScope {\n  return item && typeof item.scope === 'string';\n}\n\nexport function hasInlineLoader(item: any): item is ProviderScope {\n  return item && isObject(item.loader);\n}\n\nexport function unflatten(obj: Translation): Translation {\n  return flat.unflatten(obj, { safe: true });\n}\n\nexport function flatten(obj: Translation): Translation {\n  return flat(obj, { safe: true });\n}\n","import { InjectionToken, Provider } from '@angular/core';\nimport { AvailableLangs, HashMap } from './types';\n\nexport type TranslocoConfig = {\n  defaultLang: string;\n  reRenderOnLangChange?: boolean;\n  prodMode?: boolean;\n  fallbackLang?: string | string[];\n  failedRetries?: number;\n  /** @deprecated */\n  scopeMapping?: HashMap<string>;\n  availableLangs?: AvailableLangs;\n  flatten?: {\n    aot?: boolean;\n  };\n  missingHandler?: {\n    logMissingKey?: boolean;\n    useFallbackTranslation?: boolean;\n    allowEmpty?: boolean;\n  };\n  interpolation?: [string, string];\n};\n\nexport const TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {};\n  }\n});\n\nexport const defaultConfig: TranslocoConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n\n/**\n * @deprecated\n */\nexport function provideTranslocoConfig(config: Partial<TranslocoConfig> = defaultConfig): Provider {\n  return {\n    provide: TRANSLOCO_CONFIG,\n    useValue: { ...defaultConfig, ...config }\n  };\n}\n\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nexport function translocoConfig(config: Partial<TranslocoConfig> = defaultConfig): TranslocoConfig {\n  return { ...defaultConfig, ...config };\n}\n","import { Inject, Injectable, InjectionToken, Injector, Optional } from '@angular/core';\nimport { HashMap, Translation } from './types';\nimport { getValue, isDefined, isObject, isString, setValue } from './helpers';\nimport { defaultConfig, TRANSLOCO_CONFIG, TranslocoConfig } from './transloco.config';\n\nexport const TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\n\nexport interface TranslocoTranspiler {\n  transpile(value: any, params: HashMap, translation: HashMap): any;\n\n  onLangChanged?(lang: string): void;\n}\n\nexport class DefaultTranspiler implements TranslocoTranspiler {\n  protected interpolationMatcher: RegExp;\n\n  constructor(@Optional() @Inject(TRANSLOCO_CONFIG) userConfig?: TranslocoConfig) {\n    this.interpolationMatcher = resolveMatcher(userConfig);\n  }\n\n  transpile(value: any, params: HashMap = {}, translation: Translation): any {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher, (_, match) => {\n        match = match.trim();\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation);\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n  protected handleObject(value: any, params: HashMap = {}, translation: Translation) {\n    let result = value;\n\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p);\n      // get the params of \"b.c\" => { value: \"Transloco\" }\n      const getParams = getValue(params, p);\n\n      // transpile the value => \"Hello Transloco\"\n      const transpiled = this.transpile(v, getParams, translation);\n\n      // set \"b.c\" to `transpiled`\n      result = setValue(result, p, transpiled);\n    });\n\n    return result;\n  }\n\n  protected handleArray(value: string[], params: HashMap = {}, translation: Translation) {\n    return value.map(v => this.transpile(v, params, translation));\n  }\n}\n\nfunction resolveMatcher(userConfig?: TranslocoConfig): RegExp {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\n\nexport interface TranslocoTranspilerFunction {\n  transpile(...args: string[]): any;\n}\n\nexport function getFunctionArgs(argsString: string): string[] {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n\n  return args;\n}\n\n@Injectable()\nexport class FunctionalTranspiler extends DefaultTranspiler implements TranslocoTranspiler {\n  constructor(private injector: Injector) {\n    super();\n  }\n\n  transpile(value: any, params: HashMap = {}, translation: Translation): any {\n    let transpiled = value;\n    if (isString(value)) {\n      transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g, (match: string, functionName: string, args: string) => {\n        try {\n          const func: TranslocoTranspilerFunction = this.injector.get(functionName);\n\n          return func.transpile(...getFunctionArgs(args));\n        } catch (e) {\n          let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n          if (e.message.includes('NullInjectorError')) {\n            message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n          }\n          throw new Error(message);\n        }\n      });\n    }\n\n    return super.transpile(transpiled, params, translation);\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { TranslocoConfig } from './transloco.config';\nimport { HashMap } from './types';\n\nexport const TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\n\nexport interface TranslocoMissingHandlerData extends TranslocoConfig {\n  activeLang: string;\n}\n\nexport interface TranslocoMissingHandler {\n  handle(key: string, data: TranslocoMissingHandlerData, params?: HashMap): any;\n}\n\nexport class DefaultHandler implements TranslocoMissingHandler {\n  handle(key: string, config: TranslocoConfig) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n\n    return key;\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { Translation } from './types';\n\nexport const TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\n\nexport interface TranslocoInterceptor {\n  preSaveTranslation(translation: Translation, lang: string): Translation;\n\n  preSaveTranslationKey(key: string, value: string, lang: string): string;\n}\n\nexport class DefaultInterceptor implements TranslocoInterceptor {\n  preSaveTranslation(translation: Translation, lang: string): Translation {\n    return translation;\n  }\n\n  preSaveTranslationKey(key: string, value: string, lang: string): string {\n    return value;\n  }\n}\n","import { Inject, InjectionToken } from '@angular/core';\nimport { TRANSLOCO_CONFIG, TranslocoConfig } from './transloco.config';\n\nexport const TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken<TranslocoFallbackStrategy>('TRANSLOCO_FALLBACK_STRATEGY');\n\nexport interface TranslocoFallbackStrategy {\n  getNextLangs(failedLang: string): string[];\n}\n\nexport class DefaultFallbackStrategy implements TranslocoFallbackStrategy {\n  constructor(@Inject(TRANSLOCO_CONFIG) private userConfig: TranslocoConfig) {}\n\n  getNextLangs(failedLang: string) {\n    const fallbackLang = this.userConfig.fallbackLang;\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n}\n","import { Inject, Injectable, OnDestroy, Optional } from '@angular/core';\nimport { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, Observable, of, Subject, Subscription } from 'rxjs';\nimport { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { DefaultLoader, TRANSLOCO_LOADER, TranslocoLoader } from './transloco.loader';\nimport { TRANSLOCO_TRANSPILER, TranslocoTranspiler } from './transloco.transpiler';\nimport {\n  AvailableLangs,\n  HashMap,\n  InlineLoader,\n  LoadOptions,\n  ProviderScope,\n  SetTranslationOptions,\n  TranslateObjectParams,\n  TranslateParams,\n  Translation,\n  TranslocoEvents,\n  TranslocoScope\n} from './types';\nimport { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';\nimport { defaultConfig, TRANSLOCO_CONFIG, TranslocoConfig } from './transloco.config';\nimport {\n  TRANSLOCO_MISSING_HANDLER,\n  TranslocoMissingHandler,\n  TranslocoMissingHandlerData\n} from './transloco-missing-handler';\nimport { TRANSLOCO_INTERCEPTOR, TranslocoInterceptor } from './transloco.interceptor';\nimport { TRANSLOCO_FALLBACK_STRATEGY, TranslocoFallbackStrategy } from './transloco-fallback-strategy';\nimport { mergeConfig } from './merge-config';\nimport { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';\nimport { getFallbacksLoaders } from './get-fallbacks-loaders';\nimport { resolveLoader } from './resolve-loader';\n\nlet service: TranslocoService;\n\nexport function translate<T = any>(key: TranslateParams, params: HashMap = {}, lang?: string): T {\n  return service.translate(key, params, lang);\n}\n\n@Injectable({ providedIn: 'root' })\nexport class TranslocoService implements OnDestroy {\n  private subscription: Subscription;\n  private translations = new Map<string, Translation>();\n  private cache = new Map<string, Observable<Translation>>();\n  private firstFallbackLang: string | null = null;\n  private defaultLang: string;\n  private mergedConfig: TranslocoConfig;\n  private availableLangs: AvailableLangs = [];\n  private isResolvedMissingOnce = false;\n  private lang: BehaviorSubject<string>;\n  langChanges$: Observable<string>;\n\n  private events = new Subject<TranslocoEvents>();\n  events$ = this.events.asObservable();\n\n  private failedLangs = new Set<string>();\n\n  constructor(\n    @Optional() @Inject(TRANSLOCO_LOADER) private loader: TranslocoLoader,\n    @Inject(TRANSLOCO_TRANSPILER) private parser: TranslocoTranspiler,\n    @Inject(TRANSLOCO_MISSING_HANDLER) private missingHandler: TranslocoMissingHandler,\n    @Inject(TRANSLOCO_INTERCEPTOR) private interceptor: TranslocoInterceptor,\n    @Inject(TRANSLOCO_CONFIG) private userConfig: TranslocoConfig,\n    @Inject(TRANSLOCO_FALLBACK_STRATEGY) private fallbackStrategy: TranslocoFallbackStrategy\n  ) {\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, userConfig);\n\n    this.setAvailableLangs(this.mergedConfig.availableLangs);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject<string>(this.getDefaultLang());\n    // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n    this.langChanges$ = this.lang.asObservable();\n\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        // Handle scoped lang\n        const lang = getLangFromScope(e.payload.lang);\n        this.setActiveLang(lang);\n      }\n    });\n  }\n\n  get config(): TranslocoConfig {\n    return this.mergedConfig;\n  }\n\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n\n  setDefaultLang(lang: string) {\n    this.defaultLang = lang;\n  }\n\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n\n  setActiveLang(lang: string) {\n    this.lang.next(lang);\n    this.parser.onLangChanged && this.parser.onLangChanged(lang);\n    return this;\n  }\n\n  setAvailableLangs(langs: AvailableLangs) {\n    this.availableLangs = langs;\n  }\n\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n\n  load(path: string, options: LoadOptions = {}): Observable<Translation> {\n    if (this.cache.has(path) === false) {\n      let loadTranslation: Observable<Translation | { translation: Translation; lang: string }[]>;\n      const isScope = this._isLangScoped(path);\n      const scope = isScope ? getScopeFromLang(path) : null;\n      if (this.useFallbackTranslation(path)) {\n        // if the path is scope the fallback should be `scope/fallbackLang`;\n        const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n\n        const loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope });\n        loadTranslation = forkJoin(loaders);\n      } else {\n        const loader = resolveLoader(path, this.loader, options.inlineLoader, { scope });\n        loadTranslation = from(loader);\n      }\n\n      const load$ = loadTranslation.pipe(\n        retry(this.config.failedRetries),\n        tap(translation => {\n          if (Array.isArray(translation)) {\n            translation.forEach(t => {\n              this.handleSuccess(t.lang, t.translation);\n              // Save the fallback in cache so we'll not create a redundant request\n              if (t.lang !== path) {\n                this.cache.set(t.lang, of({}));\n              }\n            });\n            return;\n          }\n          this.handleSuccess(path, translation);\n        }),\n        catchError(() => this.handleFailure(path, options)),\n        shareReplay(1)\n      );\n\n      this.cache.set(path, load$);\n    }\n\n    return this.cache.get(path);\n  }\n\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n  translate<T = any>(key: TranslateParams, params: HashMap = {}, lang = this.getActiveLang()): T {\n    if (!key) return key as any;\n\n    const { scope, resolveLang } = this.resolveLangAndScope(lang);\n\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang)) as any;\n    }\n\n    key = scope ? `${scope}.${key}` : key;\n\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n\n    return this.parser.transpile(value, params, translation);\n  }\n\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n  selectTranslate<T = any>(\n    key: TranslateParams,\n    params?: HashMap,\n    lang?: string | TranslocoScope,\n    _isObject = false\n  ): Observable<T> {\n    let inlineLoader = null;\n    const load = (lang, options?: LoadOptions) =>\n      this.load(lang, options).pipe(\n        map(() => (_isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)))\n      );\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = lang as ProviderScope;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n\n    lang = lang as string;\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    }\n    // it's a scope\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, { inlineLoader })));\n  }\n\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n  private isScopeWithLang(lang: string) {\n    return this.isLang(getLangFromScope(lang));\n  }\n\n  /**\n   * Translate the given path that returns an object\n   *\n   * @example\n   *\n   * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\n   *\n   */\n  translateObject<T = any>(key: string, params?: HashMap, lang?: string): T;\n  translateObject<T = any>(key: string[], params?: HashMap, lang?: string): T[];\n  translateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T | T[];\n  translateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): T[];\n  translateObject<T = any>(key: TranslateObjectParams, params?: HashMap, lang = this.getActiveLang()): T | T[] {\n    if (isString(key) || Array.isArray(key)) {\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang)) as any;\n      }\n      const { resolveLang, scope } = this.resolveLangAndScope(lang);\n\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n    }\n\n    const translations: T[] = [];\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n\n    return translations;\n  }\n\n  selectTranslateObject<T = any>(key: string, params?: HashMap, lang?: string): Observable<T>;\n  selectTranslateObject<T = any>(key: string[], params?: HashMap, lang?: string): Observable<T[]>;\n  selectTranslateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): Observable<T[]>;\n  selectTranslateObject<T = any>(\n    key: TranslateObjectParams,\n    params?: HashMap,\n    lang?: string\n  ): Observable<T> | Observable<T[]> {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate<T>(key, params, lang, true);\n    }\n\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n    return this.selectTranslateObject<T>(firstKey, firstParams, lang).pipe(\n      map(value => {\n        const translations = [value];\n        for (const [_key, _params] of rest) {\n          translations.push(this.translateObject<T>(_key, _params, lang));\n        }\n\n        return translations;\n      })\n    );\n  }\n\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * getTranslation()\n   * getTranslation('en')\n   * getTranslation('admin-page/en')\n   */\n  getTranslation(): Map<string, Translation>;\n  getTranslation(langOrScope: string): Translation;\n  getTranslation(langOrScope?: string): Map<string, Translation> | Translation {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const { scope, resolveLang } = this.resolveLangAndScope(langOrScope);\n        const translation = this.translations.get(resolveLang) || {};\n\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n\n    return this.translations;\n  }\n\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   */\n  selectTranslation(lang?: string): Observable<Translation> {\n    let language$ = this.langChanges$;\n    if (lang) {\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(currentLang => `${lang}/${currentLang}`));\n      }\n    }\n\n    return language$.pipe(switchMap(language => this.load(language).pipe(map(() => this.getTranslation(language)))));\n  }\n\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n  setTranslation(translation: Translation, lang = this.getActiveLang(), options: SetTranslationOptions = {}) {\n    const defaults = { merge: true, emitChange: true };\n    const mergedOptions = { ...defaults, ...options };\n    const scope = getScopeFromLang(lang);\n\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n    let flattenScopeOrTranslation = translation;\n\n    // Merged the scoped language into the active language\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({ [key]: translation });\n    }\n\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n\n    const mergedTranslation = {\n      ...(mergedOptions.merge && this.getTranslation(currentLang)),\n      ...flattenScopeOrTranslation\n    };\n\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   */\n  setTranslationKey(key: string, value: string, lang = this.getActiveLang()) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      ...this.getTranslation(lang),\n      [key]: withHook\n    };\n\n    this.setTranslation(newValue, lang);\n  }\n\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n  setFallbackLangForMissingTranslation({ fallbackLang }: Pick<TranslocoConfig, 'fallbackLang'>): void {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n    if (this.useFallbackTranslation(lang) && fallbackLang) {\n      this.firstFallbackLang = lang;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _handleMissingKey(key: string, value: any, params?: HashMap) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n\n    if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n\n  /**\n   * @internal\n   */\n  _isLangScoped(lang: string) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n  isLang(lang: string): boolean {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n  _loadDependencies(path: string, inlineLoader?: InlineLoader): Observable<Translation | Translation[]> {\n    const mainLang = getLangFromScope(path);\n\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n    }\n    return this.load(path, { inlineLoader });\n  }\n\n  /**\n   * @internal\n   */\n  _completeScopeWithLang(langOrScope: string) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n    return langOrScope;\n  }\n\n  /**\n   * @internal\n   */\n  _setScopeAlias(scope: string, alias: string) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n\n  private isLoadedTranslation(lang: string) {\n    return size(this.getTranslation(lang));\n  }\n\n  private getAvailableLangsIds(): string[] {\n    const first = this.getAvailableLangs()[0];\n\n    if (isString(first)) {\n      return this.getAvailableLangs() as string[];\n    }\n\n    return (this.getAvailableLangs() as { id: string }[]).map(l => l.id);\n  }\n\n  private getMissingHandlerData(): TranslocoMissingHandlerData {\n    return {\n      ...this.config,\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    };\n  }\n\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n  private useFallbackTranslation(lang?: string) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n\n  private handleSuccess(lang: string, translation: Translation) {\n    this.setTranslation(translation, lang, { emitChange: false });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n\n  private handleFailure(lang: string, loadOptions: LoadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n\n    const splitted = lang.split('/');\n    const fallbacks = loadOptions.fallbackLangs;\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang);\n\n    // This handles the case where a loaded fallback language is requested again\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n\n      throw new Error(msg);\n    }\n\n    let resolveLang = nextLang;\n    // if it's scoped lang\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n\n    return this.load(resolveLang, loadOptions);\n  }\n\n  private getMappedScope(scope: string): string {\n    const { scopeMapping = {} } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n  private resolveLangAndScope(lang: string) {\n    let resolveLang = lang;\n    let scope;\n\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang);\n      // en is lang\n      const hasLang = this.isLang(langFromScope);\n      // take en\n      resolveLang = hasLang ? langFromScope : this.getActiveLang();\n      // find the scope\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n    return { scope, resolveLang };\n  }\n\n  private getObjectByKey(translation: Translation, key: string) {\n    const result = {};\n    const prefix = `${key}.`;\n\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n\n    return result;\n  }\n\n  private getEntries(key: HashMap | Map<string, HashMap>) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n}\n","import { TranslocoService } from './transloco.service';\nimport { hasInlineLoader, isString } from './helpers';\nimport { take } from 'rxjs/operators';\nimport { InlineLoader, TranslocoScope } from './types';\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nexport function getScopeFromLang(lang: string): string {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nexport function getLangFromScope(lang: string): string {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  return split.pop();\n}\n\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nexport function getPipeValue(str: string, value: string, char = '|'): [boolean, string] {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nexport function shouldListenToLangChanges(service: TranslocoService, lang: string) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (hasStatic === false) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return service.config.reRenderOnLangChange;\n  }\n\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\n\nexport function listenOrNotOperator(listenToLangChange: boolean) {\n  return listenToLangChange ? source => source : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nexport function resolveInlineLoader(providerScope: TranslocoScope | null, scope: string): InlineLoader | null {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : null;\n}\n\nexport function getEventPayload(lang: string) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang),\n    lang\n  };\n}\n","import { TranslocoLoader, TranslocoLoaderData } from './transloco.loader';\nimport { InlineLoader } from './types';\nimport { isFunction } from './helpers';\n\nexport function resolveLoader(\n  path: string,\n  mainLoader: TranslocoLoader,\n  inlineLoader: InlineLoader,\n  data: TranslocoLoaderData\n) {\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n\n    return inlineLoader[path]().then(res => (res.default ? res.default : res));\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n","import { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { resolveLoader } from './resolve-loader';\nimport { TranslocoLoader, TranslocoLoaderData } from './transloco.loader';\nimport { InlineLoader } from './types';\n\nexport function getFallbacksLoaders(\n  mainPath: string,\n  fallbackPath: string,\n  mainLoader: TranslocoLoader,\n  inlineLoader: InlineLoader,\n  data: TranslocoLoaderData\n) {\n  return [mainPath, fallbackPath].map(path => {\n    const loader = resolveLoader(path, mainLoader, inlineLoader, data);\n\n    return from(loader).pipe(\n      map(translation => ({\n        translation,\n        lang: path\n      }))\n    );\n  });\n}\n","import { TranslocoConfig } from './transloco.config';\n\nexport function mergeConfig(defaultConfig: TranslocoConfig, userConfig: Partial<TranslocoConfig>) {\n  return {\n    ...defaultConfig,\n    ...userConfig,\n    missingHandler: {\n      ...defaultConfig.missingHandler,\n      ...userConfig.missingHandler\n    },\n    flatten: {\n      ...defaultConfig.flatten,\n      ...userConfig.flatten\n    }\n  };\n}\n","import { Component, Input } from '@angular/core';\r\n\r\n@Component({\r\n  template: `\r\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\r\n  `\r\n})\r\nexport class TranslocoLoaderComponent {\r\n  @Input() html: string;\r\n}\r\n","import { ComponentRef, TemplateRef, ViewContainerRef, ComponentFactoryResolver, Injector, Type } from '@angular/core';\r\nimport { isString } from './helpers';\r\nimport { TranslocoLoaderComponent } from './loader-component.component';\r\n\r\nexport type View = string | TemplateRef<any> | Type<any>;\r\n\r\nexport class TemplateHandler {\r\n  private injector: Injector;\r\n\r\n  constructor(private view: View, private vcr: ViewContainerRef) {\r\n    this.injector = this.vcr.injector;\r\n  }\r\n\r\n  attachView() {\r\n    if (this.view instanceof TemplateRef) {\r\n      this.vcr.createEmbeddedView(this.view);\r\n    } else if (isString(this.view)) {\r\n      const componentRef = this.createComponent<TranslocoLoaderComponent>(TranslocoLoaderComponent);\r\n      componentRef.instance.html = this.view;\r\n      componentRef.hostView.detectChanges();\r\n    } else {\r\n      this.createComponent(this.view);\r\n    }\r\n  }\r\n\r\n  detachView() {\r\n    this.vcr.clear();\r\n  }\r\n\r\n  private createComponent<T>(cmp: Type<any>): ComponentRef<T> {\r\n    const cfr = this.injector.get(ComponentFactoryResolver);\r\n    const factory = cfr.resolveComponentFactory(cmp);\r\n\r\n    return this.vcr.createComponent(factory);\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\n\nexport const TRANSLOCO_LANG = new InjectionToken<string>('TRANSLOCO_LANG');\n","import { InjectionToken, ComponentRef } from '@angular/core';\n\nexport const TRANSLOCO_LOADING_TEMPLATE = new InjectionToken<{ component: ComponentRef<any> | string }>(\n  'TRANSLOCO_LOADING_TEMPLATE'\n);\n","import { InjectionToken } from '@angular/core';\nimport { TranslocoScope } from './types';\n\nexport const TRANSLOCO_SCOPE = new InjectionToken<TranslocoScope>('TRANSLOCO_SCOPE');\n","import { getLangFromScope, getPipeValue, getScopeFromLang } from './shared';\n\ntype LangResolverParams = {\n  inline: string | undefined;\n  provider: string | undefined;\n  active: string | undefined;\n};\n\nexport class LangResolver {\n  initialized = false;\n\n  // inline => provider => active\n  resolve(\n    { inline, provider, active }: LangResolverParams = { inline: undefined, provider: undefined, active: undefined }\n  ) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n\n    if (provider) {\n      const [_, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n\n    if (inline) {\n      const [_, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n\n    this.initialized = true;\n    return lang;\n  }\n\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n  resolveLangBasedOnScope(lang: string) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n  resolveLangPath(lang: string, scope: string | undefined) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\n","import { TranslocoScope, ProviderScope, MaybeArray } from './types';\nimport { TranslocoService } from './transloco.service';\nimport { isScopeObject, toCamelCase } from './helpers';\n\ntype ScopeResolverParams = {\n  inline: string | undefined;\n  provider: MaybeArray<TranslocoScope>;\n};\n\nexport class ScopeResolver {\n  constructor(private translocoService: TranslocoService) {}\n\n  // inline => provider\n  resolve({ inline, provider }: ScopeResolverParams = { inline: undefined, provider: undefined }): string {\n    if (inline) {\n      return inline;\n    }\n\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const { scope, alias = toCamelCase(scope) } = provider as ProviderScope;\n        this.translocoService._setScopeAlias(scope, alias);\n        return scope;\n      }\n\n      return provider as string;\n    }\n\n    return undefined;\n  }\n}\n","import {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EmbeddedViewRef,\n  Inject,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  TemplateRef,\n  Type,\n  ViewContainerRef\n} from '@angular/core';\nimport { forkJoin, Observable, Subscription } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TemplateHandler, View } from './template-handler';\nimport { TRANSLOCO_LANG } from './transloco-lang';\nimport { TRANSLOCO_LOADING_TEMPLATE } from './transloco-loading-template';\nimport { TRANSLOCO_SCOPE } from './transloco-scope';\nimport { TranslocoService } from './transloco.service';\nimport { HashMap, MaybeArray, Translation, TranslocoScope } from './types';\nimport { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';\nimport { LangResolver } from './lang-resolver';\nimport { ScopeResolver } from './scope-resolver';\n\n@Directive({\n  selector: '[transloco]'\n})\nexport class TranslocoDirective implements OnInit, OnDestroy, OnChanges {\n  subscription: Subscription | null;\n  view: EmbeddedViewRef<any>;\n  private translationMemo: { [key: string]: { value: any; params: HashMap } } = {};\n\n  @Input('transloco') key: string;\n  @Input('translocoParams') params: HashMap = {};\n  @Input('translocoScope') inlineScope: string | undefined;\n  @Input('translocoRead') inlineRead: string | undefined;\n  @Input('translocoLang') inlineLang: string | undefined;\n  @Input('translocoLoadingTpl') inlineTpl: TemplateRef<any> | undefined;\n\n  private currentLang: string;\n  private loaderTplHandler: TemplateHandler = null;\n  // Whether we already rendered the view once\n  private initialized = false;\n  private path: string;\n  private langResolver = new LangResolver();\n  private scopeResolver = new ScopeResolver(this.translocoService);\n\n  constructor(\n    private translocoService: TranslocoService,\n    @Optional() private tpl: TemplateRef<{ $implicit: (key: string, params?: HashMap) => any }>,\n    @Optional() @Inject(TRANSLOCO_SCOPE) private providerScope: MaybeArray<TranslocoScope>,\n    @Optional() @Inject(TRANSLOCO_LANG) private providerLang: string | null,\n    @Optional() @Inject(TRANSLOCO_LOADING_TEMPLATE) private providedLoadingTpl: Type<any> | string,\n    private vcr: ViewContainerRef,\n    private cdr: ChangeDetectorRef,\n    private host: ElementRef\n  ) {}\n\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n\n    this.subscription = this.translocoService.langChanges$\n      .pipe(\n        switchMap(activeLang => {\n          const lang = this.langResolver.resolve({\n            inline: this.inlineLang,\n            provider: this.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(this.providerScope)\n            ? forkJoin(\n                (<TranslocoScope[]>this.providerScope).map(providerScope => this.resolveScope(lang, providerScope))\n              )\n            : this.resolveScope(lang, this.providerScope);\n        }),\n        listenOrNotOperator(listenToLangChange)\n      )\n      .subscribe(() => {\n        this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.tpl === null ? this.simpleStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n        this.cdr.markForCheck();\n        this.initialized = true;\n      });\n\n    const loadingTpl = this.getLoadingTpl();\n    if (!this.initialized && loadingTpl) {\n      this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n      this.loaderTplHandler.attachView();\n    }\n  }\n\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    const notInit = Object.keys(changes).some(v => changes[v].firstChange === false);\n    notInit && this.simpleStrategy();\n  }\n\n  private simpleStrategy() {\n    this.detachLoader();\n    this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n  }\n\n  private structuralStrategy(lang: string, read: string | undefined) {\n    this.translationMemo = {};\n\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read)\n      });\n    }\n  }\n\n  private getTranslateFn(lang: string, read: string | undefined): (key: string, params?: HashMap) => any {\n    return (key: string, params: HashMap) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n      if (this.translationMemo.hasOwnProperty(withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n      this.translationMemo[withParams] = {\n        params,\n        value: this.translocoService.translate(withRead, params, lang)\n      };\n\n      return this.translationMemo[withParams].value;\n    };\n  }\n\n  private getLoadingTpl(): View {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n\n  ngOnDestroy() {\n    this.subscription && this.subscription.unsubscribe();\n  }\n\n  private detachLoader() {\n    this.loaderTplHandler && this.loaderTplHandler.detachView();\n  }\n\n  private resolveScope(lang: string, providerScope: TranslocoScope): Observable<Translation | Translation[]> {\n    let resolvedScope = this.scopeResolver.resolve({ inline: this.inlineScope, provider: providerScope });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\n","import { ChangeDetectorRef, Inject, OnDestroy, Optional, Pipe, PipeTransform } from '@angular/core';\nimport { TranslocoService } from './transloco.service';\nimport { HashMap, MaybeArray, Translation, TranslocoScope } from './types';\nimport { switchMap } from 'rxjs/operators';\nimport { forkJoin, Observable, Subscription } from 'rxjs';\nimport { TRANSLOCO_SCOPE } from './transloco-scope';\nimport { TRANSLOCO_LANG } from './transloco-lang';\nimport { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';\nimport { LangResolver } from './lang-resolver';\nimport { ScopeResolver } from './scope-resolver';\n\n@Pipe({\n  name: 'transloco',\n  pure: false\n})\nexport class TranslocoPipe implements PipeTransform, OnDestroy {\n  private subscription: Subscription | null = null;\n  private lastValue: string = '';\n  private lastKey: string | undefined;\n  private listenToLangChange: boolean;\n  private path: string;\n  private langResolver = new LangResolver();\n  private scopeResolver = new ScopeResolver(this.translocoService);\n\n  constructor(\n    private translocoService: TranslocoService,\n    @Optional() @Inject(TRANSLOCO_SCOPE) private providerScope: MaybeArray<TranslocoScope>,\n    @Optional() @Inject(TRANSLOCO_LANG) private providerLang: string | null,\n    private cdr: ChangeDetectorRef\n  ) {\n    this.listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang);\n  }\n\n  // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n  transform(key: string | null, params?: HashMap | undefined, inlineLang?: string | undefined): string {\n    if (!key) {\n      return key;\n    }\n\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n\n    this.lastKey = keyName;\n    this.subscription && this.subscription.unsubscribe();\n\n    this.subscription = this.translocoService.langChanges$\n      .pipe(\n        switchMap(activeLang => {\n          const lang = this.langResolver.resolve({\n            inline: inlineLang,\n            provider: this.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(this.providerScope)\n            ? forkJoin(\n                (<TranslocoScope[]>this.providerScope).map(providerScope => this.resolveScope(lang, providerScope))\n              )\n            : this.resolveScope(lang, this.providerScope);\n        }),\n        listenOrNotOperator(this.listenToLangChange)\n      )\n      .subscribe(() => this.updateValue(key, params));\n\n    return this.lastValue;\n  }\n\n  ngOnDestroy() {\n    this.subscription && this.subscription.unsubscribe();\n  }\n\n  private updateValue(key: string, params?: HashMap | undefined) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.translocoService.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n\n  private resolveScope(lang: string, providerScope: TranslocoScope): Observable<Translation | Translation[]> {\n    let resolvedScope = this.scopeResolver.resolve({ inline: undefined, provider: providerScope });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { TranslocoLoaderComponent } from './loader-component.component';\nimport { TranslocoDirective } from './transloco.directive';\nimport { DefaultTranspiler, TRANSLOCO_TRANSPILER } from './transloco.transpiler';\nimport { TranslocoPipe } from './transloco.pipe';\nimport { DefaultHandler, TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';\nimport { DefaultInterceptor, TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';\nimport { DefaultFallbackStrategy, TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';\nimport { TRANSLOCO_CONFIG } from './transloco.config';\n\nexport const defaultProviders = [\n  {\n    provide: TRANSLOCO_TRANSPILER,\n    useClass: DefaultTranspiler,\n    deps: [TRANSLOCO_CONFIG]\n  },\n  {\n    provide: TRANSLOCO_MISSING_HANDLER,\n    useClass: DefaultHandler\n  },\n  {\n    provide: TRANSLOCO_INTERCEPTOR,\n    useClass: DefaultInterceptor\n  },\n  {\n    provide: TRANSLOCO_FALLBACK_STRATEGY,\n    useClass: DefaultFallbackStrategy,\n    deps: [TRANSLOCO_CONFIG]\n  }\n];\n\n@NgModule({\n  declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n  providers: [defaultProviders],\n  exports: [TranslocoDirective, TranslocoPipe],\n  entryComponents: [TranslocoLoaderComponent]\n})\nexport class TranslocoModule {}\n","import { APP_INITIALIZER, Inject, Injectable, InjectionToken, ModuleWithProviders, NgModule } from '@angular/core';\nimport { TRANSLOCO_LOADER, TranslocoLoader } from './transloco.loader';\nimport { HashMap, Translation } from './types';\nimport { Observable, of } from 'rxjs';\nimport { defaultProviders, TranslocoModule } from './transloco.module';\nimport { TRANSLOCO_CONFIG, TranslocoConfig, translocoConfig } from './transloco.config';\nimport { TranslocoService } from './transloco.service';\n\nexport interface TranslocoTestingOptions {\n  translocoConfig?: Partial<TranslocoConfig>;\n  preloadLangs?: boolean;\n  langs?: HashMap<Translation>;\n}\n\nconst TRANSLOCO_TEST_LANGS = new InjectionToken<HashMap<Translation>>(\n  'TRANSLOCO_TEST_LANGS - Available testing languages'\n);\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken<TranslocoTestingOptions>('TRANSLOCO_TEST_OPTIONS - Testing options');\n\n@Injectable()\nexport class TestingLoader implements TranslocoLoader {\n  constructor(@Inject(TRANSLOCO_TEST_LANGS) private langs: HashMap<Translation>) {}\n\n  getTranslation(lang: string): Observable<Translation> | Promise<Translation> {\n    return of(this.langs[lang]);\n  }\n}\n\nexport function initTranslocoService(\n  service: TranslocoService,\n  langs: HashMap<Translation> = {},\n  options: TranslocoTestingOptions\n) {\n  const preloadAllLangs = () =>\n    options.preloadLangs\n      ? Promise.all(Object.keys(langs).map(lang => service.load(lang).toPromise()))\n      : Promise.resolve();\n\n  return preloadAllLangs;\n}\n\n@NgModule({\n  exports: [TranslocoModule]\n})\nexport class TranslocoTestingModule {\n  static forRoot(options: TranslocoTestingOptions) {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [\n        {\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: options.langs\n        },\n        {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        },\n        {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        },\n        {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        },\n        defaultProviders,\n        {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig({\n            prodMode: true,\n            missingHandler: { logMissingKey: false },\n            ...options.translocoConfig\n          })\n        }\n      ]\n    };\n  }\n\n  /** @deprecated - use forRoot instead */\n  static withLangs(\n    langs: HashMap<Translation>,\n    config: Partial<TranslocoConfig> = {},\n    options: TranslocoTestingOptions = {}\n  ): ModuleWithProviders<TranslocoTestingModule> {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [\n        {\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: langs\n        },\n        {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        },\n        {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        },\n        {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        },\n        defaultProviders,\n        {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig({\n            prodMode: true,\n            missingHandler: { logMissingKey: false },\n            ...config\n          })\n        }\n      ]\n    };\n  }\n}\n","import { isBrowser } from './helpers';\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nexport function getBrowserLang(): string | undefined {\n  let browserLang = getBrowserCultureLang();\n  if (isBrowser() === false || !browserLang) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nexport function getBrowserCultureLang(): string {\n  if (isBrowser() === false) {\n    return undefined;\n  }\n\n  const navigator = window.navigator as any;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n\n  return browserCultureLang;\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","DefaultLoader","getTranslation","lang","of","translations","get","TRANSLOCO_LOADER","InjectionToken","getValue","obj","path","split","reduce","c","setValue","prop","val","lastIndex","acc","part","index","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","isScopeObject","scope","hasInlineLoader","loader","unflatten","flat","safe","flatten","TRANSLOCO_CONFIG","providedIn","factory","defaultConfig","defaultLang","reRenderOnLangChange","prodMode","failedRetries","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","interpolation","translocoConfig","config","TRANSLOCO_TRANSPILER","DefaultTranspiler","transpile","params","translation","_this","interpolationMatcher","_","match","trim","handleObject","handleArray","result","forEach","v","getParams","transpiled","map","Optional","type","Inject","args","userConfig","resolveMatcher","_a","start","end","RegExp","getFunctionArgs","argsString","splitted","_super","FunctionalTranspiler","__extends","__","constructor","create","tslib_1.__extends","functionName","func","injector","__spread","concat","message","includes","Error","Injectable","Injector","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","key","msg","console","warn","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","service","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","getNextLangs","failedLang","fallbackLang","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","listenOrNotOperator","listenToLangChange","source","take","resolveInlineLoader","providerScope","prependScope","inlineLoader","getEventPayload","langName","resolveLoader","mainLoader","data","then","res","default","TranslocoService","defineProperty","mergedConfig","getDefaultLang","setDefaultLang","getActiveLang","setActiveLang","parser","onLangChanged","setAvailableLangs","langs","getAvailableLangs","load","options","cache","has","loadTranslation","isScope","_isLangScoped","fallback","firstFallbackLang","loaders","getFallbacksLoaders","mainPath","fallbackPath","from","pipe","forkJoin","load$","retry","tap","handleSuccess","set","catchError","handleFailure","shareReplay","translate","resolveLangAndScope","resolveLang","k","_handleMissingKey","selectTranslate","_isObject","translateObject","langChanges$","switchMap","isLang","isScopeWithLang","scope_1","resolveLang_1","_b","getObjectByKey","_c","tslib_1.__values","getEntries","_d","_e","_key","_params","selectTranslateObject","firstKey","firstParams","rest","rest_1","rest_1_1","langOrScope","selectTranslation","language$","scopeLangSpecified","currentLang","language","setTranslation","mergedOptions","merge","emitChange","flattenScopeOrTranslation","getMappedScope","mergedTranslation","flattenTranslation","withHook","interceptor","setTranslationKey","newValue","setFallbackLangForMissingTranslation","isResolvedMissingOnce","getMissingHandlerData","fallbackValue","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","combineLatest","_completeScopeWithLang","_setScopeAlias","alias","scopeMapping","ngOnDestroy","subscription","unsubscribe","l","id","activeLang","events","wasFailure","failedLangs","payload","delete","clear","loadOptions","failedCounter","fallbackLangs","fallbackStrategy","nextLang","add","EMPTY","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","Map","entries","Subject","events$","asObservable","Set","mergeConfig","BehaviorSubject","subscribe","TranslocoLoaderComponent","Component","template","Input","TemplateHandler","attachView","view","TemplateRef","vcr","createEmbeddedView","componentRef","createComponent","instance","html","hostView","detectChanges","detachView","cmp","ComponentFactoryResolver","resolveComponentFactory","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","resolve","inline","provider","active","initialized","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","translocoService","TranslocoDirective","ngOnInit","providerLang","inlineLang","langResolver","resolveScope","tpl","simpleStrategy","structuralStrategy","inlineRead","cdr","markForCheck","loadingTpl","getLoadingTpl","loaderTplHandler","ngOnChanges","changes","some","firstChange","detachLoader","host","nativeElement","innerText","read","translationMemo","context","getTranslateFn","$implicit","withRead","withParams","JSON","stringify","inlineTpl","providedLoadingTpl","resolvedScope","scopeResolver","inlineScope","Directive","selector","decorators","ViewContainerRef","ChangeDetectorRef","ElementRef","TranslocoPipe","transform","keyName","lastKey","updateValue","lastValue","Pipe","name","pure","defaultProviders","provide","useClass","deps","TranslocoModule","NgModule","declarations","providers","exports","entryComponents","TRANSLOCO_TEST_LANGS","TRANSLOCO_TEST_OPTIONS","TestingLoader","initTranslocoService","preloadLangs","Promise","all","toPromise","TranslocoTestingModule","forRoot","ngModule","useValue","APP_INITIALIZER","useFactory","multi","withLangs","getBrowserCultureLang","navigator","browserCultureLang","languages","browserLanguage","userLanguage","provideTranslocoConfig","getBrowserLang","browserLang","coerceArray","toNumber","isNaN","Number","parseFloat"],"mappings":"kdAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IASrB,IAAIO,EAAW,WAQlB,OAPAA,EAAWN,OAAOO,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIN,KADTK,EAAIG,UAAUF,GACOV,OAAOc,UAAUT,eAAeU,KAAKN,EAAGL,KAAII,EAAEJ,GAAKK,EAAEL,IAE9E,OAAOI,IAEKQ,MAAMC,KAAML,YAGhC,SAqEgBM,EAASC,GACrB,IAAIV,EAAsB,mBAAXW,QAAyBA,OAAOC,SAAUC,EAAIb,GAAKU,EAAEV,GAAIC,EAAI,EAC5E,GAAIY,EAAG,OAAOA,EAAEP,KAAKI,GACrB,GAAIA,GAAyB,iBAAbA,EAAEN,OAAqB,MAAO,CAC1CU,KAAM,WAEF,OADIJ,GAAKT,GAAKS,EAAEN,SAAQM,OAAI,GACrB,CAAEK,MAAOL,GAAKA,EAAET,KAAMe,MAAON,KAG5C,MAAM,IAAIO,UAAUjB,EAAI,0BAA4B,mCAGxD,SAAgBkB,EAAOR,EAAGR,GACtB,IAAIW,EAAsB,mBAAXF,QAAyBD,EAAEC,OAAOC,UACjD,IAAKC,EAAG,OAAOH,EACf,IAAmBS,EAAYC,EAA3BnB,EAAIY,EAAEP,KAAKI,GAAOW,EAAK,GAC3B,IACI,WAAc,IAANnB,GAAsB,EAANA,QAAciB,EAAIlB,EAAEa,QAAQE,MAAMK,EAAGC,KAAKH,EAAEJ,OAExE,MAAOQ,GAASH,EAAI,CAAEG,MAAOA,WAEzB,IACQJ,IAAMA,EAAEH,OAASH,EAAIZ,EAAU,YAAIY,EAAEP,KAAKL,WAExC,GAAImB,EAAG,MAAMA,EAAEG,OAE7B,OAAOF,EC3HX,IAAAG,GAGEA,EAAAnB,UAAAoB,eAAA,SAAeC,GACb,OAAOC,EAAAA,GAAGnB,KAAKoB,aAAaC,IAAIH,IAAS,KAE7CF,GALE,SAAAA,EAAoBI,GAAApB,KAAAoB,aAAAA,EAOtB,IAAaE,EAAmB,IAAIC,EAAAA,eAA4B,oBCjBhE,SAAgBC,EAASC,EAAaC,GAEpC,OAAID,GAAOA,EAAIrC,eAAesC,GACrBD,EAAIC,GAENA,EAAKC,MAAM,KAAKC,OAAM,SAAEzC,EAAG0C,GAAM,OAAA1C,GAAKA,EAAE0C,IAAIJ,GAGrD,SAAgBK,EAASL,EAAUM,EAAcC,GAC/CP,EAAGpC,EAAA,GAAQoC,OAELE,EAAQI,EAAKJ,MAAM,KACnBM,EAAYN,EAAM/B,OAAS,EAYjC,OAVA+B,EAAMC,OAAM,SAAEM,EAAKC,EAAMC,GAOvB,OALEF,EAAIC,GADFC,IAAUH,EACAD,EAEA9C,MAAMmD,QAAQH,EAAIC,IAASD,EAAIC,GAAMG,QAAOjD,EAAA,GAAQ6C,EAAIC,IAG/DD,GAAOA,EAAIC,IACjBV,GAEIA,EAGT,SAAgBc,EAAKC,GACnB,OAAKA,EAIDtD,MAAMmD,QAAQG,GACTA,EAAW5C,OAGhB6C,EAASD,GACJzD,OAAO2D,KAAKF,GAAY5C,OAGxB4C,EAAaA,EAAW5C,OAAS,EAXjC,EAcX,SAAgB+C,EAAQH,GACtB,OAA4B,IAArBD,EAAKC,GAGd,SAAgBI,EAAWZ,GACzB,MAAsB,mBAARA,EAGhB,SAAgBa,EAASb,GACvB,MAAsB,iBAARA,EAGhB,SAAgBc,EAASd,GACvB,MAAsB,iBAARA,EAGhB,SAAgBS,EAASM,GACvB,OAAOA,GAAwB,iBAATA,IAAsB7D,MAAMmD,QAAQU,GAe5D,SAAgBC,EAAYC,GAC1B,OAAOA,EACJC,QAAQ,sBAAqB,SAAGC,EAAMf,GAAU,OAAU,GAATA,EAAae,EAAKC,cAAgBD,EAAKE,gBACxFH,QAAQ,cAAe,IAG5B,SAAgBI,IACd,MAAyB,oBAAXC,OAGhB,SAAgBC,EAAMjD,GACpB,OAAiB,OAAVA,GAAkBA,IAAUkD,UAGrC,SAAgBC,EAAUnD,GACxB,OAAwB,IAAjBiD,EAAMjD,GAaf,SAAgBoD,EAAcZ,GAC5B,OAAOA,GAA8B,iBAAfA,EAAKa,MAG7B,SAAgBC,EAAgBd,GAC9B,OAAOA,GAAQN,EAASM,EAAKe,QAG/B,SAAgBC,EAAUtC,GACxB,OAAOuC,EAAKD,UAAUtC,EAAK,CAAEwC,MAAM,IAGrC,SAAgBC,EAAQzC,GACtB,OAAOuC,EAAKvC,EAAK,CAAEwC,MAAM,IChG3B,IAAaE,EAAmB,IAAI5C,EAAAA,eAAe,mBAAoB,CACrE6C,WAAY,OACZC,QAAO,WACL,MAAO,MAIEC,EAAiC,CAC5CC,YAAa,KACbC,sBAAsB,EACtBC,UAAU,EACVC,cAAe,EACfC,eAAgB,GAChBC,eAAgB,CACdC,eAAe,EACfC,wBAAwB,EACxBC,YAAY,GAEdb,QAAS,CACPc,KAAK,GAEPC,cAAe,CAAC,KAAM,OAmBxB,SAAgBC,EAAgBC,GAC9B,YAD8B,IAAAA,IAAAA,EAAAb,GAC9BjF,EAAA,GAAYiF,EAAkBa,GC3DhC,IAAaC,EAAuB,IAAI7D,EAAAA,eAAe,2BAerD8D,EAAAxF,UAAAyF,UAAA,SAAU/E,EAAYgF,EAAsBC,GAA5C,IAAAC,EAAAzF,KACE,YADoB,IAAAuF,IAAAA,EAAA,IAChB1C,EAAStC,GACJA,EAAM2C,QAAQlD,KAAK0F,qBAAoB,SAAGC,EAAGC,GAElD,OADAA,EAAQA,EAAMC,OACVnC,EAAU6B,EAAOK,IACZL,EAAOK,GAGTlC,EAAU8B,EAAYI,IAAUH,EAAKH,UAAUE,EAAYI,GAAQL,EAAQC,GAAe,MAE1FD,IACL9C,EAASlC,GACXA,EAAQP,KAAK8F,aAAavF,EAAOgF,EAAQC,GAChCtG,MAAMmD,QAAQ9B,KACvBA,EAAQP,KAAK+F,YAAYxF,EAAOgF,EAAQC,KAIrCjF,IA2BC8E,EAAAxF,UAAAiG,aAAV,SAAuBvF,EAAYgF,EAAsBC,GAAzD,IAAAC,EAAAzF,UAAmC,IAAAuF,IAAAA,EAAA,QAC7BS,EAASzF,EAeb,OAbAxB,OAAO2D,KAAK6C,GAAQU,QAAO,SAAC9G,OAEpB+G,EAAI1E,EAASwE,EAAQ7G,GAErBgH,EAAY3E,EAAS+D,EAAQpG,GAG7BiH,EAAaX,EAAKH,UAAUY,EAAGC,EAAWX,GAGhDQ,EAASlE,EAASkE,EAAQ7G,EAAGiH,KAGxBJ,GAGCX,EAAAxF,UAAAkG,YAAV,SAAsBxF,EAAiBgF,EAAsBC,GAA7D,IAAAC,EAAAzF,KACE,YADqC,IAAAuF,IAAAA,EAAA,IAC9BhF,EAAM8F,IAAG,SAACH,GAAK,OAAAT,EAAKH,UAAUY,EAAGX,EAAQC,2EArErCc,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAACtC,QAuElCkB,GAvEE,SAAAA,EAAkDqB,GAChD1G,KAAK0F,qBAwET,SAASiB,EAAeD,GAChB,IAAAE,EAAAlG,EAAAgG,GAAAA,EAAAzB,cAAAyB,EAAAzB,cAAAX,EAAAW,cAAA,GAAC4B,EAAAD,EAAA,GAAOE,EAAAF,EAAA,GAEd,OAAO,IAAIG,OAAUF,EAAK,QAAQC,EAAO,KA3EXH,CAAeD,GAkF/C,SAAgBM,EAAgBC,GAG9B,QAFMC,EAAWD,EAAaA,EAAWtF,MAAM,KAAO,GAChD8E,EAAO,GACJhH,EAAI,EAAGA,EAAIyH,EAAStH,OAAQH,IAAK,CAExC,QADIc,EAAQ2G,EAASzH,GAAGoG,OACW,OAA5BtF,EAAMA,EAAMX,OAAS,IAC1BH,IACAc,EAAQA,EAAM2C,QAAQ,KAAM,KAAOgE,EAASzH,GAE9CgH,EAAK3F,KAAKP,GAGZ,OAAOkG,EAGT,IAAAU,EAAAC,GJ3FA,SAAgBC,GAAUxI,EAAGC,GAEzB,SAASwI,IAAOtH,KAAKuH,YAAc1I,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEgB,UAAkB,OAANf,EAAaC,OAAOyI,OAAO1I,IAAMwI,EAAGzH,UAAYf,EAAEe,UAAW,IAAIyH,GIyFzCG,CAAAA,EAD1CN,EAC0C9B,GAKxC+B,EAAAvH,UAAAyF,UAAA,SAAU/E,EAAYgF,EAAsBC,GAA5C,IAAAC,EAAAzF,UAAsB,IAAAuF,IAAAA,EAAA,QAChBa,EAAa7F,EAkBjB,OAjBIsC,EAAStC,KACX6F,EAAa7F,EAAM2C,QAAQ,6BAA4B,SAAG0C,EAAe8B,EAAsBjB,GAC7F,QACQkB,EAAoClC,EAAKmC,SAASvG,IAAIqG,GAE5D,OAAOC,EAAKrC,UAASvF,MAAd4H,EJWjB,SAAgBE,IACZ,IAAK,IAAIhH,EAAK,GAAIpB,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAC3CoB,EAAKA,EAAGiH,OAAOpH,EAAOf,UAAUF,KACpC,OAAOoB,EIdUgH,CAAcb,EAAgBP,KACzC,MAAO7F,OACHmH,EAAU,0BAA0BxH,EAAK,8HACiEmH,EAAY,eAI1H,MAHI9G,EAAEmH,QAAQC,SAAS,uBACrBD,EAAU,sBAAsBL,EAAY,6DAExC,IAAIO,MAAMF,OAKfZ,EAAAtH,UAAMyF,UAASxF,KAAAE,KAACoG,EAAYb,EAAQC,wBAzB9C0C,EAAAA,sDAlH4CC,EAAAA,YA6I7Cf,GAzBE,SAAAA,EAAoBQ,GAApB,IAAAnC,EACE0B,EAAArH,KAAAE,OAAOA,YADWyF,EAAAmC,SAAAA,IC/GtB,IAAaQ,EAA4B,IAAI7G,EAAAA,eAAe,gCAW1D8G,EAAAxI,UAAAyI,OAAA,SAAOC,EAAapD,GAClB,GAAIA,EAAOP,eAAeC,gBAAkBM,EAAOV,SAAU,KACrD+D,EAAM,4BAA4BD,EAAG,IAC3CE,QAAQC,KAAK,MAAMF,EAAO,+BAG5B,OAAOD,GAEXF,GATA,SAAAA,KCZA,IAAaM,EAAwB,IAAIpH,EAAAA,eAAe,4BAStDqH,EAAA/I,UAAAgJ,mBAAA,SAAmBrD,EAA0BtE,GAC3C,OAAOsE,GAGToD,EAAA/I,UAAAiJ,sBAAA,SAAsBP,EAAahI,EAAeW,GAChD,OAAOX,GAEXqI,GARA,SAAAA,KCRA,IC6BIG,ED7BSC,EAA8B,IAAIzH,EAAAA,eAA0C,kCASvF0H,EAAApJ,UAAAqJ,aAAA,SAAaC,OACLC,EAAepJ,KAAK0G,WAAW0C,aACrC,IAAKA,EACH,MAAM,IAAInB,MAAM,wFAGlB,OAAO/I,MAAMmD,QAAQ+G,GAAgBA,EAAe,CAACA,yEAR1C5C,EAAAA,OAAMC,KAAA,CAACtC,QAUtB8E,GAVE,SAAAA,EAA8CvC,GAAA1G,KAAA0G,WAAAA,EEChD,SAAgB2C,EAAiBnI,GAC/B,IAAKA,EACH,MAAO,OAEHS,EAAQT,EAAKS,MAAM,KAEzB,OADAA,EAAM2H,MACC3H,EAAM4H,KAAK,KASpB,SAAgBC,EAAiBtI,GAC/B,OAAKA,EAGSA,EAAKS,MAAM,KACZ2H,MAHJ,GAaX,SAAgBG,EAAaxG,EAAa1C,EAAemJ,GACvD,QADuD,IAAAA,IAAAA,EAAA,KACnD7G,EAASI,GAAM,KACXiE,EAAWjE,EAAItB,MAAM+H,GACrBC,EAAWzC,EAASoC,MAC1B,OAAOK,IAAapJ,EAAQ,EAAC,EAAM2G,EAAS0C,YAAc,EAAC,EAAOD,GAGpE,MAAO,EAAC,EAAO,IAGjB,SAAgBE,EAA0Bd,EAA2B7H,GAEnE,OAAkB,IADZR,EAAA+I,EAAAvI,EAAA,UAAA,GAAC,IAGE6H,EAAQ5D,OAAOX,qBAO1B,SAAgBsF,EAAoBC,GAClC,OAAOA,EAAkB,SAAGC,GAAU,OAAAA,GAASC,EAAAA,KAAK,GAUtD,SAAgBC,EAAoBC,EAAsCvG,GACxE,OAAOC,EAAgBsG,GARzB,SAASC,EAAaC,EAAczG,GAClC,OAAO7E,OAAO2D,KAAK2H,GAAczI,OAAM,SAAEM,EAAKhB,GAE5C,OADAgB,EAAO0B,EAAK,IAAI1C,GAAUmJ,EAAanJ,GAChCgB,GACN,IAIqCkI,CAAaD,EAAcrG,OAAQF,GAAS,KAGtF,SAAgB0G,GAAgBpJ,GAC9B,MAAO,CACL0C,MAAOyF,EAAiBnI,IAAS,KACjCqJ,SAAUf,EAAiBtI,GAC3BA,KAAIA,GC7ER,SAAgBsJ,GACd9I,EACA+I,EACAJ,EACAK,GAEA,GAAIL,EAAc,CAEhB,IAA+B,IAA3BzH,EADeyH,EAAa3I,IAE9B,KAAM,iEAAiEA,EAGzE,OAAO2I,EAAa3I,KAAQiJ,KAAI,SAACC,GAAO,OAACA,EAAIC,WAAUD,EAAIC,WAAUD,IAGvE,OAAOH,EAAWxJ,eAAeS,EAAMgJ,GFmBzC,IAAAI,IAoDE/L,OAAAgM,eAAID,GAAAjL,UAAA,SAAM,KAAV,WACE,OAAOG,KAAKgL,8CAGdF,GAAAjL,UAAAoL,eAAA,WACE,OAAOjL,KAAKuE,aAGduG,GAAAjL,UAAAqL,eAAA,SAAehK,GACblB,KAAKuE,YAAcrD,GAGrB4J,GAAAjL,UAAAsL,cAAA,WACE,OAAOnL,KAAKkB,KAAKM,YAGnBsJ,GAAAjL,UAAAuL,cAAA,SAAclK,GAGZ,OAFA,KAAKA,KAAKZ,KAAKY,GACf,KAAKmK,OAAOC,eAAiB,KAAKD,OAAOC,cAAcpK,GACvD,MAGF4J,GAAAjL,UAAA0L,kBAAA,SAAkBC,GAChBxL,KAAK2E,eAAiB6G,GAUxBV,GAAAjL,UAAA4L,kBAAA,WACE,OAAOzL,KAAK2E,gBAGdmG,GAAAjL,UAAA6L,KAAA,SAAKhK,EAAciK,GAAnB,IAAAlG,EAAAzF,KACE,QADiB,IAAA2L,IAAAA,EAAA,KACY,IAAzB3L,KAAK4L,MAAMC,IAAInK,GAAiB,KAC9BoK,OAAe,EACbC,EAAU/L,KAAKgM,cAActK,GAC7BkC,EAAQmI,EAAU1C,EAAiB3H,GAAQ,KACjD,GAAI1B,KAAK8E,uBAAuBpD,GAAO,KAE/BuK,EAAWF,EAAanI,EAAK,IAAI5D,KAAKkM,kBAAsBlM,KAAKkM,kBAEjEC,EGlId,SAAgBC,EACdC,EACAC,EACA7B,EACAJ,EACAK,GAEA,MAAO,CAAC2B,EAAUC,GAAcjG,IAAG,SAAC3E,OAC5BoC,EAAS0G,GAAc9I,EAAM+I,EAAYJ,EAAcK,GAE7D,OAAO6B,EAAAA,KAAKzI,GAAQ0I,KAClBnG,EAAAA,IAAG,SAACb,GAAe,MAAA,CACjBA,YAAWA,EACXtE,KAAMQ,QHqHU0K,CAAoB1K,EAAMuK,EAAUjM,KAAK8D,OAAQ6H,EAAQtB,aAAc,CAAEzG,MAAKA,IAC9FkI,EAAkBW,EAAAA,SAASN,OACtB,KACCrI,EAAS0G,GAAc9I,EAAM1B,KAAK8D,OAAQ6H,EAAQtB,aAAc,CAAEzG,MAAKA,IAC7EkI,EAAkBS,EAAAA,KAAKzI,OAGnB4I,EAAQZ,EAAgBU,KAC5BG,EAAAA,MAAM3M,KAAKmF,OAAOT,eAClBkI,EAAAA,IAAG,SAACpH,GACEtG,MAAMmD,QAAQmD,GAChBA,EAAYS,QAAO,SAAC1G,GAClBkG,EAAKoH,cAActN,EAAE2B,KAAM3B,EAAEiG,aAEzBjG,EAAE2B,OAASQ,GACb+D,EAAKmG,MAAMkB,IAAIvN,EAAE2B,KAAMC,EAAAA,GAAG,OAKhCsE,EAAKoH,cAAcnL,EAAM8D,KAE3BuH,EAAAA,WAAU,WAAO,OAAAtH,EAAKuH,cAActL,EAAMiK,KAC1CsB,EAAAA,YAAY,IAGdjN,KAAK4L,MAAMkB,IAAIpL,EAAMgL,GAGvB,OAAO1M,KAAK4L,MAAMvK,IAAIK,IAcxBoJ,GAAAjL,UAAAqN,UAAA,SAAmB3E,EAAsBhD,EAAsBrE,GAA/D,IAAAuE,EAAAzF,KACE,QADuC,IAAAuF,IAAAA,EAAA,SAAsB,IAAArE,IAAAA,EAAOlB,KAAKmL,kBACpE5C,EAAK,OAAA,EAEJ,IAAA3B,EAAA5G,KAAAmN,oBAAAjM,GAAE0C,EAAAgD,EAAAhD,MAAOwJ,EAAAxG,EAAAwG,YAEf,GAAIlO,MAAMmD,QAAQkG,GAChB,OAAOA,EAAIlC,IAAG,SAACgH,GAAK,OAAA5H,EAAKyH,UAAUtJ,EAAWA,EAAK,IAAIyJ,EAAMA,EAAG9H,EAAQ6H,KAG1E7E,EAAM3E,EAAWA,EAAK,IAAI2E,EAAQA,MAE5B/C,EAAcxF,KAAKiB,eAAemM,GAClC7M,EAAQiF,EAAY+C,GAE1B,OAAKhI,EAIEP,KAAKqL,OAAO/F,UAAU/E,EAAOgF,EAAQC,GAHnCxF,KAAKsN,kBAAkB/E,EAAKhI,EAAOgF,IAiB9CuF,GAAAjL,UAAA0N,gBAAA,SACEhF,EACAhD,EACArE,EACAsM,GAJF,IAAA/H,EAAAzF,UAIE,IAAAwN,IAAAA,GAAA,OAEInD,EAAe,KACbqB,EAAI,SAAIxK,EAAMyK,GAClB,OAAAlG,EAAKiG,KAAKxK,EAAMyK,GAASa,KACvBnG,EAAAA,IAAG,WAAO,OAACmH,EAAY/H,EAAKgI,gBAAgBlF,EAAKhD,EAAQrE,GAAQuE,EAAKyH,UAAU3E,EAAKhD,EAAQrE,OAEjG,GAAIsC,EAAMtC,GACR,OAAOlB,KAAK0N,aAAalB,KAAKmB,EAAAA,UAAS,SAACzM,GAAQ,OAAAwK,EAAKxK,MAGvD,GAAIyC,EAAczC,GAAO,KAEjBiJ,EAAa,EACnBjJ,EAAOiJ,EAAcvG,MACrByG,EAAeH,EAAoBC,EAAeA,EAAcvG,OAIlE,GADA1C,EAAI,EACAlB,KAAK4N,OAAO1M,IAASlB,KAAK6N,gBAAgB3M,GAC5C,OAAOwK,EAAKxK,OAGR0C,EAAQ1C,EACd,OAAOlB,KAAK0N,aAAalB,KAAKmB,EAAAA,UAAS,SAACzM,GAAQ,OAAAwK,EAAQ9H,EAAK,IAAI1C,EAAQ,CAAEmJ,aAAYA,QAWjFS,GAAAjL,UAAAgO,gBAAR,SAAwB3M,GACtB,OAAOlB,KAAK4N,OAAOpE,EAAiBtI,KAetC4J,GAAAjL,UAAA4N,gBAAA,SAAyBlF,EAA4BhD,EAAkBrE,GAAvE,QAAAuE,EAAAzF,KACE,QADqE,IAAAkB,IAAAA,EAAOlB,KAAKmL,iBAC7EtI,EAAS0F,IAAQrJ,MAAMmD,QAAQkG,GAAM,CACvC,GAAIrJ,MAAMmD,QAAQkG,GAChB,OAAOA,EAAIlC,IAAG,SAACgH,GAAK,OAAA5H,EAAKgI,gBAAgBK,EAAWA,EAAK,IAAIT,EAAMA,EAAG9H,EAAQwI,KAE1E,IAAAC,EAAAhO,KAAAmN,oBAAAjM,GAAE6M,EAAAC,EAAAZ,YAAaU,EAAAE,EAAApK,MAEf4B,EAAcxF,KAAKiB,eAAe8M,GACxCxF,EAAMuF,EAAWA,EAAK,IAAIvF,EAAQA,MAE5BhI,EAAQwD,EAAU/D,KAAKiO,eAAezI,EAAa+C,IAEzD,OAAO5F,EAAQpC,GAASP,KAAKkN,UAAU3E,EAAKhD,EAAQrE,GAAQlB,KAAKqL,OAAO/F,UAAU/E,EAAOgF,EAAQC,OAG7FpE,EAAoB,OAC1B,IAA8B,IAAA8M,EAAAC,EAAAnO,KAAKoO,WAAW7F,IAAI8F,EAAAH,EAAA5N,QAAA+N,EAAA7N,KAAA6N,EAAAH,EAAA5N,OAAE,CAAzC,IAAAgO,EAAA5N,EAAA2N,EAAA9N,MAAA,GAACgO,EAAAD,EAAA,GAAME,EAAAF,EAAA,GAChBlN,EAAaN,KAAKd,KAAKyN,gBAAgBc,EAAMC,EAAStN,yGAGxD,OAAOE,GAMT0J,GAAAjL,UAAA4O,sBAAA,SACElG,EACAhD,EACArE,GAHF,IAAAuE,EAAAzF,KAKE,GAAI6C,EAAS0F,IAAQrJ,MAAMmD,QAAQkG,GACjC,OAAOvI,KAAKuN,gBAAmBhF,EAAKhD,EAAQrE,GAAM,GAG9C,IAAA0F,EAAAlG,EAAAV,KAAAoO,WAAA7F,IAACyF,EAAAtN,EAAAkG,EAAA,GAAA,GAAC8H,EAAAV,EAAA,GAAUW,EAAAX,EAAA,GAAcY,EAAAhI,EAAAtE,MAAA,GAIhC,OAAOtC,KAAKyO,sBAAyBC,EAAUC,EAAazN,GAAMsL,KAChEnG,EAAAA,IAAG,SAAC9F,WACIa,EAAe,CAACb,OACtB,IAA8B,IAAAsO,EAAAV,EAAAS,GAAIE,EAAAD,EAAAvO,QAAAwO,EAAAtO,KAAAsO,EAAAD,EAAAvO,OAAE,CAAzB,IAAA0N,EAAAtN,EAAAoO,EAAAvO,MAAA,GAACgO,EAAAP,EAAA,GAAMQ,EAAAR,EAAA,GAChB5M,EAAaN,KAAK2E,EAAKgI,gBAAmBc,EAAMC,EAAStN,yGAG3D,OAAOE,MAgBb0J,GAAAjL,UAAAoB,eAAA,SAAe8N,GACb,GAAIA,EAAa,CACf,GAAI/O,KAAK4N,OAAOmB,GACd,OAAO/O,KAAKoB,aAAaC,IAAI0N,IAAgB,GAGvC,IAAAnI,EAAA5G,KAAAmN,oBAAA4B,GAAEnL,EAAAgD,EAAAhD,MAAOwJ,EAAAxG,EAAAwG,YACT5H,EAAcxF,KAAKoB,aAAaC,IAAI+L,IAAgB,GAE1D,OAAOpN,KAAKiO,eAAezI,EAAa5B,GAI5C,OAAO5D,KAAKoB,cAad0J,GAAAjL,UAAAmP,kBAAA,SAAkB9N,GAAlB,IAAAuE,EAAAzF,KACMiP,EAAYjP,KAAK0N,aACrB,GAAIxM,EAAM,KACFgO,EAAqB1F,EAAiBtI,KAAUA,EAEpD+N,EADEjP,KAAK4N,OAAO1M,IAASgO,EACX/N,EAAAA,GAAGD,GAEHlB,KAAK0N,aAAalB,KAAKnG,EAAAA,IAAG,SAAC8I,GAAe,OAAGjO,EAAI,IAAIiO,KAIrE,OAAOF,EAAUzC,KAAKmB,EAAAA,UAAS,SAACyB,GAAY,OAAA3J,EAAKiG,KAAK0D,GAAU5C,KAAKnG,EAAAA,IAAG,WAAO,OAAAZ,EAAKxE,eAAemO,UAarGtE,GAAAjL,UAAAwP,eAAA,SAAe7J,EAA0BtE,EAA6ByK,cAA7B,IAAAzK,IAAAA,EAAOlB,KAAKmL,sBAAiB,IAAAQ,IAAAA,EAAA,QAE9D2D,EAAajQ,EAAA,GADF,CAAEkQ,OAAO,EAAMC,YAAY,GACJ7D,GAClC/H,EAAQyF,EAAiBnI,GAM3BuO,EAA4BjK,EAG5B5B,IAEF6L,EAA4BvL,IAAO0C,EAAA,IADvB5G,KAAK0P,eAAe9L,IACa4B,EAAWoB,SAGpDuI,EAAcvL,EAAQ4F,EAAiBtI,GAAQA,EAE/CyO,EAAiBtQ,EAAA,GACjBiQ,EAAcC,OAASvP,KAAKiB,eAAekO,GAC5CM,GAGCG,EAAqB5P,KAAKgL,aAAa9G,QAAQc,IAAM2K,EAAoBzL,EAAQyL,GACjFE,EAAW7P,KAAK8P,YAAYjH,mBAAmB+G,EAAoBT,GACzEnP,KAAKoB,aAAa0L,IAAIqC,EAAaU,GACnCP,EAAcE,YAAcxP,KAAKoL,cAAcpL,KAAKmL,kBAYtDL,GAAAjL,UAAAkQ,kBAAA,SAAkBxH,EAAahI,EAAeW,cAAA,IAAAA,IAAAA,EAAOlB,KAAKmL,qBAClD0E,EAAW7P,KAAK8P,YAAYhH,sBAAsBP,EAAKhI,EAAOW,GAC9D8O,EAAQ3Q,EAAA,GACTW,KAAKiB,eAAeC,KAAK0F,EAAA,IAC3B2B,GAAMsH,EAAQjJ,IAGjB5G,KAAKqP,eAAeW,EAAU9O,IAOhC4J,GAAAjL,UAAAoQ,qCAAA,SAAqCrJ,OAAEwC,EAAAxC,EAAAwC,aAC/BlI,EAAOhC,MAAMmD,QAAQ+G,GAAgBA,EAAa,GAAKA,EACzDpJ,KAAK8E,uBAAuB5D,IAASkI,IACvCpJ,KAAKkM,kBAAoBhL,IAO7B4J,GAAAjL,UAAAyN,kBAAA,SAAkB/E,EAAahI,EAAYgF,GACzC,GAAIvF,KAAKmF,OAAOP,eAAeG,YAAwB,KAAVxE,EAC3C,MAAO,GAGT,IAAIP,KAAK8E,0BAA6B9E,KAAKkQ,sBAQ3C,OAAOlQ,KAAK4E,eAAe0D,OAAOC,EAAKvI,KAAKmQ,wBAAyB5K,GANnEvF,KAAKkQ,uBAAwB,MACvBE,EAAgBpQ,KAAKkN,UAAU3E,EAAKhD,EAAQvF,KAAKkM,mBAEvD,OADAlM,KAAKkQ,uBAAwB,EACtBE,GASXtF,GAAAjL,UAAAmM,cAAA,SAAc9K,GACZ,OAAsD,IAA/ClB,KAAKqQ,uBAAuBC,QAAQpP,IAS7C4J,GAAAjL,UAAA+N,OAAA,SAAO1M,GACL,OAAsD,IAA/ClB,KAAKqQ,uBAAuBC,QAAQpP,IAS7C4J,GAAAjL,UAAA0Q,kBAAA,SAAkB7O,EAAc2I,OACxBmG,EAAWhH,EAAiB9H,GAElC,OAAI1B,KAAKgM,cAActK,KAAU1B,KAAKyQ,oBAAoBD,GACjDE,EAAAA,cAAc1Q,KAAK0L,KAAK8E,GAAWxQ,KAAK0L,KAAKhK,EAAM,CAAE2I,aAAYA,KAEnErK,KAAK0L,KAAKhK,EAAM,CAAE2I,aAAYA,KAMvCS,GAAAjL,UAAA8Q,uBAAA,SAAuB5B,GACrB,OAAI/O,KAAKgM,cAAc+C,KAAiB/O,KAAK4N,OAAOpE,EAAiBuF,IACzDA,EAAW,IAAI/O,KAAKmL,gBAEzB4D,GAMTjE,GAAAjL,UAAA+Q,eAAA,SAAehN,EAAeiN,GACvB7Q,KAAKgL,aAAa8F,eACrB9Q,KAAKgL,aAAa8F,aAAe,IAEnC9Q,KAAKgL,aAAa8F,aAAalN,GAASiN,GAG1C/F,GAAAjL,UAAAkR,YAAA,WACE/Q,KAAKgR,aAAaC,eAGZnG,GAAAjL,UAAA4Q,oBAAR,SAA4BvP,GAC1B,OAAOqB,EAAKvC,KAAKiB,eAAeC,KAG1B4J,GAAAjL,UAAAwQ,qBAAR,WAGE,OAAIxN,EAFU7C,KAAKyL,oBAAoB,IAG9BzL,KAAKyL,oBAGNzL,KAAKyL,oBAAyCpF,IAAG,SAAC6K,GAAK,OAAAA,EAAEC,MAG3DrG,GAAAjL,UAAAsQ,sBAAR,WACE,OAAA9Q,EAAA,GACKW,KAAKmF,OAAM,CACdiM,WAAYpR,KAAKmL,gBACjBxG,eAAgB3E,KAAK2E,eACrBJ,YAAavE,KAAKuE,eAQduG,GAAAjL,UAAAiF,uBAAR,SAA+B5D,GAC7B,OAAOlB,KAAKmF,OAAOP,eAAeE,wBAA0B5D,IAASlB,KAAKkM,mBAGpEpB,GAAAjL,UAAAgN,cAAR,SAAsB3L,EAAcsE,GAApC,IAAAC,EAAAzF,KACEA,KAAKqP,eAAe7J,EAAatE,EAAM,CAAEsO,YAAY,IACrDxP,KAAKqR,OAAO/Q,KAAK,CACfgR,aAActR,KAAKuR,YAAYhP,KAC/BgE,KAAM,yBACNiL,QAASlH,GAAgBpJ,KAE3BlB,KAAKuR,YAAYtL,QAAO,SAACiL,GAAK,OAAAzL,EAAKmG,MAAM6F,UAAOP,KAChDlR,KAAKuR,YAAYG,SAGX5G,GAAAjL,UAAAmN,cAAR,SAAsB9L,EAAcyQ,GAG9BnO,EAAMmO,EAAYC,iBACpBD,EAAYC,cAAgB,EAEvBD,EAAYE,gBACfF,EAAYE,cAAgB7R,KAAK8R,iBAAiB5I,aAAahI,SAI7DgG,EAAWhG,EAAKS,MAAM,KAEtBoQ,EADYJ,EAAYE,cACHF,EAAYC,eAIvC,GAHA5R,KAAKuR,YAAYS,IAAI9Q,GAGjBlB,KAAK4L,MAAMC,IAAIkG,GAEjB,OADA/R,KAAK6M,cAAckF,EAAU/R,KAAKiB,eAAe8Q,IAC1CE,EAAAA,UAGHC,EAAiBH,IAAa7K,EAASA,EAAStH,OAAS,GAE/D,IAAKmS,GAAYG,EAAgB,KAC3B1J,EAAM,4DAKV,MAJsB,EAAlBtB,EAAStH,SACX4I,GAAO,wCAGH,IAAIP,MAAMO,OAGd4E,EAAc2E,EAelB,OAbsB,EAAlB7K,EAAStH,SAGXsH,EAASA,EAAStH,OAAS,GAAKmS,EAChC3E,EAAclG,EAASqC,KAAK,MAG9BoI,EAAYC,gBACZ5R,KAAKqR,OAAO/Q,KAAK,CACfiG,KAAM,yBACNiL,QAASlH,GAAgBpJ,KAGpBlB,KAAK0L,KAAK0B,EAAauE,IAGxB7G,GAAAjL,UAAA6P,eAAR,SAAuB9L,GACb,IAAAgD,EAAA5G,KAAAmF,OAAA2L,aACR,YADQ,IAAAlK,EAAA,GAAAA,GACYhD,IAAUZ,EAAYY,IAQpCkH,GAAAjL,UAAAsN,oBAAR,SAA4BjM,OAEtB0C,EADAwJ,EAAclM,EAGlB,GAAIlB,KAAKgM,cAAc9K,GAAO,KAEtBiR,EAAgB3I,EAAiBtI,GAEjCkR,EAAUpS,KAAK4N,OAAOuE,GAE5B/E,EAAcgF,EAAUD,EAAgBnS,KAAKmL,gBAE7CvH,EAAQ5D,KAAK0P,eAAe0C,EAAU/I,EAAiBnI,GAAQA,GAEjE,MAAO,CAAE0C,MAAKA,EAAEwJ,YAAWA,IAGrBtC,GAAAjL,UAAAoO,eAAR,SAAuBzI,EAA0B+C,OACzCvC,EAAS,GACTqM,EAAY9J,EAAG,IAErB,IAAK,IAAM+J,KAAc9M,EACnB8M,EAAWC,WAAWF,KACxBrM,EAAOsM,EAAWpP,QAAQmP,EAAQ,KAAO7M,EAAY8M,IAIzD,OAAOtM,GAGD8E,GAAAjL,UAAAuO,WAAR,SAAmB7F,GACjB,OAAOA,aAAeiK,IAAMjK,EAAIkK,UAAY1T,OAAO0T,QAAQlK,yBAjmB9DL,EAAAA,WAAUzB,KAAA,CAAC,CAAErC,WAAY,iFAmBrBkC,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAACnF,wCACnBkF,EAAAA,OAAMC,KAAA,CAACrB,wCACPoB,EAAAA,OAAMC,KAAA,CAAC2B,wCACP5B,EAAAA,OAAMC,KAAA,CAACkC,wCACPnC,EAAAA,OAAMC,KAAA,CAACtC,wCACPqC,EAAAA,OAAMC,KAAA,CAACuC,6LANV,SAAA8B,GACgDhH,EACRuH,EACKzG,EACJkL,EACLpJ,EACWoL,GAN/C,IAAArM,EAAAzF,KACgDA,KAAA8D,OAAAA,EACR9D,KAAAqL,OAAAA,EACKrL,KAAA4E,eAAAA,EACJ5E,KAAA8P,YAAAA,EACL9P,KAAA0G,WAAAA,EACW1G,KAAA8R,iBAAAA,EArBvC9R,KAAAoB,aAAe,IAAIoR,IACnBxS,KAAA4L,MAAQ,IAAI4G,IACZxS,KAAAkM,kBAAmC,KAGnClM,KAAA2E,eAAiC,GACjC3E,KAAAkQ,uBAAwB,EAIxBlQ,KAAAqR,OAAS,IAAIqB,EAAAA,QACrB1S,KAAA2S,QAAU3S,KAAKqR,OAAOuB,eAEd5S,KAAAuR,YAAc,IAAIsB,IAUnB7S,KAAK8D,SACR9D,KAAK8D,OAAS,IAAI9C,EAAchB,KAAKoB,gBAEvC2H,EAAU/I,MACLgL,aIlET,SAAgB8H,EAAYxO,EAAgCoC,GAC1D,OAAArH,EAAA,GACKiF,EACAoC,EAAU,CACb9B,eAAcvF,EAAA,GACTiF,EAAcM,eACd8B,EAAW9B,gBAEhBV,QAAO7E,EAAA,GACFiF,EAAcJ,QACdwC,EAAWxC,WJwDI4O,CAAYxO,EAAeoC,GAE/C1G,KAAKuL,kBAAkBvL,KAAKgL,aAAarG,gBACzC3E,KAAKiQ,qCAAqCjQ,KAAKgL,cAC/ChL,KAAKkL,eAAelL,KAAKgL,aAAazG,aACtCvE,KAAKkB,KAAO,IAAI6R,EAAAA,gBAAwB/S,KAAKiL,kBAG7CjL,KAAK0N,aAAe1N,KAAKkB,KAAK0R,eAK9B5S,KAAKgR,aAAehR,KAAK2S,QAAQK,UAAS,SAACpS,GACzC,GAAe,2BAAXA,EAAE2F,MAAqC3F,EAAE0Q,WAAY,KAEjDpQ,EAAOsI,EAAiB5I,EAAE4Q,QAAQtQ,MACxCuE,EAAK2F,cAAclK,MKrF3B,IAAA+R,yBAECC,EAAAA,UAASzM,KAAA,CAAC,CACT0M,SAAU,gHAKTC,EAAAA,SACHH,IAPA,SAAAA,MCFA,IAAAI,IAaEA,GAAAxT,UAAAyT,WAAA,WACE,GAAItT,KAAKuT,gBAAgBC,EAAAA,YACvBxT,KAAKyT,IAAIC,mBAAmB1T,KAAKuT,WAC5B,GAAI1Q,EAAS7C,KAAKuT,MAAO,KACxBI,EAAe3T,KAAK4T,gBAA0CX,IACpEU,EAAaE,SAASC,KAAO9T,KAAKuT,KAClCI,EAAaI,SAASC,qBAEtBhU,KAAK4T,gBAAgB5T,KAAKuT,OAI9BF,GAAAxT,UAAAoU,WAAA,WACEjU,KAAKyT,IAAI/B,SAGH2B,GAAAxT,UAAA+T,gBAAR,SAA2BM,OAEnB7P,EADMrE,KAAK4H,SAASvG,IAAI8S,EAAAA,0BACVC,wBAAwBF,GAE5C,OAAOlU,KAAKyT,IAAIG,gBAAgBvP,IAEpCgP,IA1BE,SAAAA,GAAoBE,EAAoBE,GAApBzT,KAAAuT,KAAAA,EAAoBvT,KAAAyT,IAAAA,EACtCzT,KAAK4H,SAAW5H,KAAKyT,IAAI7L,SCR7B,IAAayM,GAAiB,IAAI9S,EAAAA,eAAuB,kBCA5C+S,GAA6B,IAAI/S,EAAAA,eAC5C,8BCAWgT,GAAkB,IAAIhT,EAAAA,eAA+B,mBCKlEiT,IAIEA,GAAA3U,UAAA4U,QAAA,SACE7N,OAAAoH,OAAA,IAAApH,EAAA,CAAA8N,OAAAjR,UAAAkR,SAAAlR,UAAAmR,OAAAnR,WAAAmD,EAAE8N,EAAA1G,EAAA0G,OAAQC,EAAA3G,EAAA2G,SAAUC,EAAA5G,EAAA4G,OAEhB1T,EAAO0T,EAKX,GAAI5U,KAAK6U,YAEP,OADA3T,EAAO0T,EAIT,GAAID,EAAU,CACN,IAAAzG,EAAAxN,EAAA+I,EAAAkL,EAAA,UAAA,GAACzG,EAAA,GACPhN,EADUgN,EAAA,GAIZ,GAAIwG,EAAQ,CACJ,IAAArG,EAAA3N,EAAA+I,EAAAiL,EAAA,UAAA,GAACrG,EAAA,GACPnN,EADUmN,EAAA,GAKZ,OADArO,KAAK6U,aAAc,EACZ3T,GAaTsT,GAAA3U,UAAAiV,wBAAA,SAAwB5T,GAEtB,OADcmI,EAAiBnI,GAChBsI,EAAiBtI,GAAQA,GAa1CsT,GAAA3U,UAAAkV,gBAAA,SAAgB7T,EAAc0C,GAC5B,OAAOA,EAAWA,EAAK,IAAI1C,EAASA,GAExCsT,IA3DA,SAAAA,KACExU,KAAA6U,aAAc,ECAhB,IAAAG,IAIEA,GAAAnV,UAAA4U,QAAA,SAAQ7N,OAAAoH,OAAA,IAAApH,EAAA,CAAA8N,OAAAjR,UAAAkR,SAAAlR,WAAAmD,EAAE8N,EAAA1G,EAAA0G,OAAQC,EAAA3G,EAAA2G,SAChB,GAAID,EACF,OAAOA,EAGT,GAAIC,EAAU,CACZ,GAAIhR,EAAcgR,GAAW,CACrB,IAAE/Q,EAAF,EAAEA,MAAOyK,EAAT,EAASwC,MAAAA,OAAA,IAAAxC,EAAArL,EAAAY,GAAAyK,EAEf,OADArO,KAAKiV,iBAAiBrE,eAAehN,EAAOiN,GACrCjN,EAGT,OAAA,EAGF,OAAOH,WAEXuR,IApBE,SAAAA,GAAoBC,GAAAjV,KAAAiV,iBAAAA,ECVtB,IAAAC,IA6DEA,GAAArV,UAAAsV,SAAA,WAAA,IAAA1P,EAAAzF,KACQ+J,EAAqBF,EAA0B7J,KAAKiV,iBAAkBjV,KAAKoV,cAAgBpV,KAAKqV,YAEtGrV,KAAKgR,aAAehR,KAAKiV,iBAAiBvH,aACvClB,KACCmB,EAAAA,UAAS,SAACyD,OACFlQ,EAAOuE,EAAK6P,aAAab,QAAQ,CACrCC,OAAQjP,EAAK4P,WACbV,SAAUlP,EAAK2P,aACfR,OAAQxD,IAGV,OAAOlS,MAAMmD,QAAQoD,EAAK0E,eACtBsC,EAAAA,SACqBhH,EAAkB,cAAEY,IAAG,SAAC8D,GAAiB,OAAA1E,EAAK8P,aAAarU,EAAMiJ,MAEtF1E,EAAK8P,aAAarU,EAAMuE,EAAK0E,iBAEnCL,EAAoBC,IAErBiJ,UAAS,WACRvN,EAAK0J,YAAc1J,EAAK6P,aAAaR,wBAAwBrP,EAAK/D,MACrD,OAAb+D,EAAK+P,IAAe/P,EAAKgQ,iBAAmBhQ,EAAKiQ,mBAAmBjQ,EAAK0J,YAAa1J,EAAKkQ,YAC3FlQ,EAAKmQ,IAAIC,eACTpQ,EAAKoP,aAAc,QAGjBiB,EAAa9V,KAAK+V,iBACnB/V,KAAK6U,aAAeiB,IACvB9V,KAAKgW,iBAAmB,IAAI3C,GAAgByC,EAAY9V,KAAKyT,KAC7DzT,KAAKgW,iBAAiB1C,eAI1B4B,GAAArV,UAAAoW,YAAA,SAAYC,GAGMnX,OAAO2D,KAAKwT,GAASC,KAAI,SAACjQ,GAAK,OAA2B,IAA3BgQ,EAAQhQ,GAAGkQ,eAC/CpW,KAAKyV,kBAGVP,GAAArV,UAAA4V,eAAR,WACEzV,KAAKqW,eACLrW,KAAKsW,KAAKC,cAAcC,UAAYxW,KAAKiV,iBAAiB/H,UAAUlN,KAAKuI,IAAKvI,KAAKuF,OAAQvF,KAAKmP,cAG1F+F,GAAArV,UAAA6V,mBAAR,SAA2BxU,EAAcuV,GACvCzW,KAAK0W,gBAAkB,GAEnB1W,KAAKuT,KAEPvT,KAAKuT,KAAKoD,QAAmB,UAAI3W,KAAK4W,eAAe1V,EAAMuV,IAE3DzW,KAAKqW,eACLrW,KAAKuT,KAAOvT,KAAKyT,IAAIC,mBAAmB1T,KAAKwV,IAAK,CAChDqB,UAAW7W,KAAK4W,eAAe1V,EAAMuV,OAKnCvB,GAAArV,UAAA+W,eAAR,SAAuB1V,EAAcuV,GAArC,IAAAhR,EAAAzF,KACE,OAAA,SAAQuI,EAAahD,OACbuR,EAAWL,EAAUA,EAAI,IAAIlO,EAAQA,EACrCwO,EAAaxR,EAAS,GAAGuR,EAAWE,KAAKC,UAAU1R,GAAYuR,EACrE,OAAIrR,EAAKiR,gBAAgBtX,eAAe2X,KAGxCtR,EAAKiR,gBAAgBK,GAAc,CACjCxR,OAAMA,EACNhF,MAAOkF,EAAKwP,iBAAiB/H,UAAU4J,EAAUvR,EAAQrE,KAJlDuE,EAAKiR,gBAAgBK,GAAYxW,QAWtC2U,GAAArV,UAAAkW,cAAR,WACE,OAAO/V,KAAKkX,WAAalX,KAAKmX,oBAGhCjC,GAAArV,UAAAkR,YAAA,WACE/Q,KAAKgR,cAAgBhR,KAAKgR,aAAaC,eAGjCiE,GAAArV,UAAAwW,aAAR,WACErW,KAAKgW,kBAAoBhW,KAAKgW,iBAAiB/B,cAGzCiB,GAAArV,UAAA0V,aAAR,SAAqBrU,EAAciJ,OAC7BiN,EAAgBpX,KAAKqX,cAAc5C,QAAQ,CAAEC,OAAQ1U,KAAKsX,YAAa3C,SAAUxK,IACrFnK,KAAK0B,KAAO1B,KAAKsV,aAAaP,gBAAgB7T,EAAMkW,OAC9C/M,EAAeH,EAAoBC,EAAeiN,GACxD,OAAOpX,KAAKiV,iBAAiB1E,kBAAkBvQ,KAAK0B,KAAM2I,yBA9H7DkN,EAAAA,UAAS9Q,KAAA,CAAC,CACT+Q,SAAU,4DAPH1M,UAVP0I,EAAAA,YAAWiE,WAAA,CAAA,CAAAlR,KAyCRD,EAAAA,8CACAA,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAAC8N,yCACnBjO,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAAC4N,yCACnB/N,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAAC6N,aA1CtBoD,EAAAA,wBAZAC,EAAAA,yBAEAC,EAAAA,4CAgCCxE,EAAAA,MAAK3M,KAAA,CAAC,6BACN2M,EAAAA,MAAK3M,KAAA,CAAC,wCACN2M,EAAAA,MAAK3M,KAAA,CAAC,sCACN2M,EAAAA,MAAK3M,KAAA,CAAC,qCACN2M,EAAAA,MAAK3M,KAAA,CAAC,oCACN2M,EAAAA,MAAK3M,KAAA,CAAC,0BAmHTyO,IAzGE,SAAAA,GACUD,EACYO,EACyBrL,EACDiL,EACY+B,EAChD1D,EACAmC,EACAU,GAPAtW,KAAAiV,iBAAAA,EACYjV,KAAAwV,IAAAA,EACyBxV,KAAAmK,cAAAA,EACDnK,KAAAoV,aAAAA,EACYpV,KAAAmX,mBAAAA,EAChDnX,KAAAyT,IAAAA,EACAzT,KAAA4V,IAAAA,EACA5V,KAAAsW,KAAAA,EAzBFtW,KAAA0W,gBAAsE,GAGpD1W,KAAAuF,OAAkB,GAOpCvF,KAAAgW,iBAAoC,KAEpChW,KAAA6U,aAAc,EAEd7U,KAAAsV,aAAe,IAAId,GACnBxU,KAAAqX,cAAgB,IAAIrC,GAAchV,KAAKiV,kBChDjD,IAAA4C,IAkCEA,GAAAhY,UAAAiY,UAAA,SAAUvP,EAAoBhD,EAA8B8P,GAA5D,IAAA5P,EAAAzF,KACE,IAAKuI,EACH,OAAOA,MAGHwP,EAAUxS,EAAS,GAAGgD,EAAMyO,KAAKC,UAAU1R,GAAYgD,EAE7D,OAAIwP,IAAY/X,KAAKgY,UAIrBhY,KAAKgY,QAAUD,EACf/X,KAAKgR,cAAgBhR,KAAKgR,aAAaC,cAEvCjR,KAAKgR,aAAehR,KAAKiV,iBAAiBvH,aACvClB,KACCmB,EAAAA,UAAS,SAACyD,OACFlQ,EAAOuE,EAAK6P,aAAab,QAAQ,CACrCC,OAAQW,EACRV,SAAUlP,EAAK2P,aACfR,OAAQxD,IAGV,OAAOlS,MAAMmD,QAAQoD,EAAK0E,eACtBsC,EAAAA,SACqBhH,EAAkB,cAAEY,IAAG,SAAC8D,GAAiB,OAAA1E,EAAK8P,aAAarU,EAAMiJ,MAEtF1E,EAAK8P,aAAarU,EAAMuE,EAAK0E,iBAEnCL,EAAoB9J,KAAK+J,qBAE1BiJ,UAAS,WAAO,OAAAvN,EAAKwS,YAAY1P,EAAKhD,MAvBhCvF,KAAKkY,WA4BhBL,GAAAhY,UAAAkR,YAAA,WACE/Q,KAAKgR,cAAgBhR,KAAKgR,aAAaC,eAGjC4G,GAAAhY,UAAAoY,YAAR,SAAoB1P,EAAahD,OACzBrE,EAAOlB,KAAKsV,aAAaR,wBAAwB9U,KAAK0B,MAC5D1B,KAAKkY,UAAYlY,KAAKiV,iBAAiB/H,UAAU3E,EAAKhD,EAAQrE,GAC9DlB,KAAK4V,IAAIC,gBAGHgC,GAAAhY,UAAA0V,aAAR,SAAqBrU,EAAciJ,OAC7BiN,EAAgBpX,KAAKqX,cAAc5C,QAAQ,CAAEC,OAAQjR,UAAWkR,SAAUxK,IAC9EnK,KAAK0B,KAAO1B,KAAKsV,aAAaP,gBAAgB7T,EAAMkW,OAC9C/M,EAAeH,EAAoBC,EAAeiN,GACxD,OAAOpX,KAAKiV,iBAAiB1E,kBAAkBvQ,KAAK0B,KAAM2I,yBAzE7D8N,EAAAA,KAAI1R,KAAA,CAAC,CACJ2R,KAAM,YACNC,MAAM,gDAZCvN,sCAyBJxE,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAAC8N,yCACnBjO,EAAAA,UAAQ,CAAAC,KAAIC,EAAAA,OAAMC,KAAA,CAAC4N,aA3BfsD,EAAAA,qBAsFTE,IA9DE,SAAAA,GACU5C,EACqC9K,EACDiL,EACpCQ,GAHA5V,KAAAiV,iBAAAA,EACqCjV,KAAAmK,cAAAA,EACDnK,KAAAoV,aAAAA,EACpCpV,KAAA4V,IAAAA,EAZF5V,KAAAgR,aAAoC,KACpChR,KAAAkY,UAAoB,GAIpBlY,KAAAsV,aAAe,IAAId,GACnBxU,KAAAqX,cAAgB,IAAIrC,GAAchV,KAAKiV,kBAQ7CjV,KAAK+J,mBAAqBF,EAA0B7J,KAAKiV,iBAAkBjV,KAAKoV,cCpBpF,IAAakD,GAAmB,CAC9B,CACEC,QAASnT,EACToT,SAAUnT,EACVoT,KAAM,CAACtU,IAET,CACEoU,QAASnQ,EACToQ,SAAUnQ,GAEZ,CACEkQ,QAAS5P,EACT6P,SAAU5P,GAEZ,CACE2P,QAASvP,EACTwP,SAAUvP,EACVwP,KAAM,CAACtU,KAIXuU,yBAACC,EAAAA,SAAQlS,KAAA,CAAC,CACRmS,aAAc,CAAC1D,GAAoB2C,GAAe5E,IAClD4F,UAAW,CAACP,IACZQ,QAAS,CAAC5D,GAAoB2C,IAC9BkB,gBAAiB,CAAC9F,QAEUyF,IAN9B,SAAAA,UCjBMM,GAAuB,IAAIzX,EAAAA,eAC/B,sDAEI0X,GAAyB,IAAI1X,EAAAA,eAAwC,4CAE3E2X,IAIEA,GAAArZ,UAAAoB,eAAA,SAAeC,GACb,OAAOC,EAAAA,GAAGnB,KAAKwL,MAAMtK,0BALxBgH,EAAAA,mFAEc1B,EAAAA,OAAMC,KAAA,CAACuS,SAKtBE,IALE,SAAAA,GAAkD1N,GAAAxL,KAAAwL,MAAAA,EAOpD,SAAgB2N,GACdpQ,EACAyC,EACAG,QADA,IAAAH,IAAAA,EAAA,IAQA,OALqB,WACnB,OAAAG,EAAQyN,aACJC,QAAQC,IAAIva,OAAO2D,KAAK8I,GAAOnF,IAAG,SAACnF,GAAQ,OAAA6H,EAAQ2C,KAAKxK,GAAMqY,eAC9DF,QAAQ5E,WAKhB,IAAA+E,IAISA,GAAAC,QAAP,SAAe9N,GACb,MAAO,CACL+N,SAAUF,GACVX,UAAW,CACT,CACEN,QAASS,GACTW,SAAUhO,EAAQH,OAEpB,CACE+M,QAASU,GACTU,SAAUhO,GAEZ,CACE4M,QAASqB,EAAAA,gBACTC,WAAYV,GACZV,KAAM,CAAC3N,GAAkBkO,GAAsBC,IAC/Ca,OAAO,GAET,CACEvB,QAASjX,EACTkX,SAAUU,IAEZZ,GACA,CACEC,QAASpU,EACTwV,SAAUzU,EAAe7F,EAAA,CACvBoF,UAAU,EACVG,eAAgB,CAAEC,eAAe,IAC9B8G,EAAQzG,sBAQdsU,GAAAO,UAAP,SACEvO,EACArG,EACAwG,GAEA,YAHA,IAAAxG,IAAAA,EAAA,SACA,IAAAwG,IAAAA,EAAA,IAEO,CACL+N,SAAUF,GACVX,UAAW,CACT,CACEN,QAASS,GACTW,SAAUnO,GAEZ,CACE+M,QAASU,GACTU,SAAUhO,GAEZ,CACE4M,QAASqB,EAAAA,gBACTC,WAAYV,GACZV,KAAM,CAAC3N,GAAkBkO,GAAsBC,IAC/Ca,OAAO,GAET,CACEvB,QAASjX,EACTkX,SAAUU,IAEZZ,GACA,CACEC,QAASpU,EACTwV,SAAUzU,EAAe7F,EAAA,CACvBoF,UAAU,EACVG,eAAgB,CAAEC,eAAe,IAC9BM,6BAxEdwT,EAAAA,SAAQlS,KAAA,CAAC,CACRqS,QAAS,CAACJ,QA6EZc,IA9EA,SAAAA,MChBA,SAAgBQ,KACd,IAAoB,IAAhB1W,IACF,OAAOG,cAGHwW,EAAY1W,OAAgB,UAC9B2W,EAAqBD,EAAUE,UAAYF,EAAUE,UAAU,GAAK,KAGxE,OAFAD,EAAqBA,GAAsBD,EAAU7K,UAAY6K,EAAUG,iBAAmBH,EAAUI,yBhBE1G,SAAgBnN,GAAmB3E,EAAsBhD,EAAsBrE,GAC7E,YADuD,IAAAqE,IAAAA,EAAA,IAChDwD,EAAQmE,UAAU3E,EAAKhD,EAAQrE,qMLexC,SAAgBoZ,GAAuBnV,GACrC,YADqC,IAAAA,IAAAA,EAAAb,GAC9B,CACLiU,QAASpU,EACTwV,SAAQta,EAAA,GAAOiF,EAAkBa,kaqBhDrC,SAAgBoV,SACVC,EAAcR,KAClB,OAAoB,IAAhB1W,KAA0BkX,IAII,IAA9BA,EAAYlK,QAAQ,OACtBkK,EAAcA,EAAY7Y,MAAM,KAAK,KAGL,IAA9B6Y,EAAYlK,QAAQ,OACtBkK,EAAcA,EAAY7Y,MAAM,KAAK,IAGhC6Y,GAXE/W,yLtB0DX,SAAgBgX,GAAYzY,GAC1B,OAAO9C,MAAMmD,QAAQL,GAAOA,EAAM,CAACA,qEA6BrC,SAAgB0Y,GAASna,GACvB,OAAIuC,EAASvC,GAAeA,EAExBsC,EAAStC,KAAWoa,MAAMC,OAAOra,GAASsa,WAAWta,IAChDqa,OAAOra,GAGT"}