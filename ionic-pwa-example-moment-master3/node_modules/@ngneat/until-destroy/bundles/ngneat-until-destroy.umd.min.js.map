{"version":3,"sources":["../../src/lib/ivy.ts","../../src/lib/internals.ts","../../src/lib/until-destroy.ts","../../src/lib/until-destroyed.ts"],"names":["NG_PIPE_DEF","ɵNG_PIPE_DEF","isFunction","target","DESTROY","Symbol","DECORATOR_APPLIED","getSymbol","destroyMethodName","createSubjectOnTheInstance","instance","symbol","Subject","completeSubjectOnTheInstance","next","complete","unsubscribe","property","decorateNgOnDestroy","ngOnDestroy","options","call","this","arrayName","Array","isArray","forEach","unsubscribeIfPropertyIsArrayLike","checkProperties","_a","blackList","includes","type","def","ɵpipe","onDestroy","decoratePipe","prototype","decorateProviderDirectiveOrComponent","markAsDecorated","source","originalDestroy","ngDevMode","Error","constructor","name","apply","arguments","overrideNonDirectiveInstanceMethod","Object","getPrototypeOf","ensureClassIsDecorated","pipe","takeUntil"],"mappings":"kcAEA,IAAMA,EAAcC,EAAAA,sBCGJC,EAAWC,GACzB,MAAyB,mBAAXA,EAOhB,IAAMC,EAAyBC,OAAO,aAKzBC,EAAmCD,OAAO,+BASvCE,EAAaC,GAC3B,MAAiC,iBAAtBA,EACFH,OAAO,cAAcG,GAErBJ,WAkBKK,EAA2BC,EAAeC,GACnDD,EAASC,KACZD,EAASC,GAAU,IAAIC,EAAAA,kBAIXC,EAA6BH,EAAeC,GACtDD,EAASC,KACXD,EAASC,GAAQG,OACjBJ,EAASC,GAAQI,WAGjBL,EAASC,GAAU,MC7CvB,SAASK,EAAYC,GACnBA,GAAYf,EAAWe,EAASD,cAAgBC,EAASD,cAO3D,SAASE,EACPC,EACAC,GAEA,OAAO,iBASL,GAPAD,GAAeA,EAAYE,KAAKC,MAIhCT,EAA6BS,KAAMf,KAG/Ba,EAAQG,UACV,OAlBN,SAA0CN,GACxCO,MAAMC,QAAQR,IAAaA,EAASS,QAAQV,GAiBjCW,CAAiCL,KAAKF,EAAQG,YAIvD,GAAIH,EAAQQ,gBACV,IAAK,IAAMX,KAAYK,MACA,QAArBO,EAAIT,EAAQU,iBAAS,IAAAD,OAAA,EAAAA,EAAEE,SAASd,KAIhCD,EAAYM,KAAKL,6BAkBIG,GAC3B,YAD2B,IAAAA,IAAAA,EAAA,IACpB,SAACY,GACKA,EF1DGhC,GEmDlB,SAAyBgC,EAAmBZ,GAC1C,IAAMa,EAAMD,EAAKE,MACjBD,EAAIE,UAAYjB,EAAoBe,EAAIE,UAAWf,GAM/CgB,CAAaJ,EAAMZ,GAfzB,SACEY,EACAZ,GAEAY,EAAKK,UAAUlB,YAAcD,EAAoBc,EAAKK,UAAUlB,YAAaC,GAazEkB,CAAqCN,EAAMZ,YDnC/CY,GAIAA,EAAKK,UAAU/B,IAAqB,ECkClCiC,CAAgBP,+BCjCctB,EAAaF,GAC7C,OAAO,SAAIgC,GACT,IAAM7B,EAASJ,EAAaC,GAW5B,MAPiC,iBAAtBA,EAhCf,SACEE,EACAF,EACAG,GAEA,IAAM8B,EAAkB/B,EAASF,GAEjC,GAAIkC,YAA6C,IAAhCxC,EAAWuC,GAC1B,MAAM,IAAIE,MACLjC,EAASkC,YAAYC,KAAI,kDAAkDrC,GAIlFC,EAA2BC,EAAUC,GAErCD,EAASF,GAAqB,WAC5BiC,EAAgBK,MAAMxB,KAAMyB,WAC5BlC,EAA6BS,KAAMX,GAKnCD,EAASF,GAAqBiC,GAW5BO,CAAmCtC,EAAUF,EAAmBG,IAEhE+B,WAQN,SAAgChC,GAC9B,IAAM2B,EAAYY,OAAOC,eAAexC,GAGxC,KAF2BJ,KAAqB+B,GAG9C,MAAM,IAAIM,MACR,0IAdaQ,CAAuBzC,GACpCD,EAA2BC,EAAUC,IAGhC6B,EAAOY,KAAKC,EAAAA,UAAc3C,EAAiBC","sourcesContent":["import { Type, ɵNG_PIPE_DEF, ɵPipeDef } from '@angular/core';\n\nconst NG_PIPE_DEF = ɵNG_PIPE_DEF as 'ɵpipe';\n\n// Angular doesn't expose publicly `PipeType` but it actually has it.\nexport interface PipeType<T> extends Type<T> {\n  ɵpipe: ɵPipeDef<T>;\n}\n\nexport function isPipe<T>(target: any): target is PipeType<T> {\n  return !!target[NG_PIPE_DEF];\n}\n","import { InjectableType, ɵDirectiveType, ɵComponentType } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { PipeType } from './ivy';\n\nexport function isFunction(target: unknown) {\n  return typeof target === 'function';\n}\n\n/**\n * Applied to instances and stores `Subject` instance when\n * no custom destroy method is provided.\n */\nconst DESTROY: unique symbol = Symbol('__destroy');\n\n/**\n * Applied to definitions and informs that class is decorated\n */\nexport const DECORATOR_APPLIED: unique symbol = Symbol('__decoratorApplied');\n\n/**\n * If we use the `untilDestroyed` operator multiple times inside the single\n * instance providing different `destroyMethodName`, then all streams will\n * subscribe to the single subject. If any method is invoked, the subject will\n * emit and all streams will be unsubscribed. We wan't to prevent this behavior,\n * thus we store subjects under different symbols.\n */\nexport function getSymbol<T>(destroyMethodName?: keyof T): symbol {\n  if (typeof destroyMethodName === 'string') {\n    return Symbol(`__destroy__${destroyMethodName}`);\n  } else {\n    return DESTROY;\n  }\n}\n\nexport function markAsDecorated<T>(\n  type: InjectableType<T> | PipeType<T> | ɵDirectiveType<T> | ɵComponentType<T>\n): void {\n  // Store this property on the prototype if it's an injectable class, component or directive.\n  // We will be able to handle class extension this way.\n  type.prototype[DECORATOR_APPLIED] = true;\n}\n\nexport interface UntilDestroyOptions {\n  blackList?: string[];\n  arrayName?: string;\n  checkProperties?: boolean;\n}\n\nexport function createSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (!instance[symbol]) {\n    instance[symbol] = new Subject<void>();\n  }\n}\n\nexport function completeSubjectOnTheInstance(instance: any, symbol: symbol): void {\n  if (instance[symbol]) {\n    instance[symbol].next();\n    instance[symbol].complete();\n    // We also have to re-assign this property thus in the future\n    // we will be able to create new subject on the same instance.\n    instance[symbol] = null;\n  }\n}\n","import {\n  InjectableType,\n  ɵComponentType as ComponentType,\n  ɵDirectiveType as DirectiveType\n} from '@angular/core';\nimport { SubscriptionLike } from 'rxjs';\n\nimport { PipeType, isPipe } from './ivy';\nimport {\n  getSymbol,\n  isFunction,\n  UntilDestroyOptions,\n  completeSubjectOnTheInstance,\n  markAsDecorated\n} from './internals';\n\nfunction unsubscribe(property: SubscriptionLike | undefined): void {\n  property && isFunction(property.unsubscribe) && property.unsubscribe();\n}\n\nfunction unsubscribeIfPropertyIsArrayLike(property: any[]): void {\n  Array.isArray(property) && property.forEach(unsubscribe);\n}\n\nfunction decorateNgOnDestroy(\n  ngOnDestroy: (() => void) | null | undefined,\n  options: UntilDestroyOptions\n) {\n  return function(this: any) {\n    // Invoke the original `ngOnDestroy` if it exists\n    ngOnDestroy && ngOnDestroy.call(this);\n\n    // It's important to use `this` instead of caching instance\n    // that may lead to memory leaks\n    completeSubjectOnTheInstance(this, getSymbol());\n\n    // Check if subscriptions are pushed to some array\n    if (options.arrayName) {\n      return unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);\n    }\n\n    // Loop through the properties and find subscriptions\n    if (options.checkProperties) {\n      for (const property in this) {\n        if (options.blackList?.includes(property)) {\n          continue;\n        }\n\n        unsubscribe(this[property]);\n      }\n    }\n  };\n}\n\nfunction decorateProviderDirectiveOrComponent<T>(\n  type: InjectableType<T> | DirectiveType<T> | ComponentType<T>,\n  options: UntilDestroyOptions\n): void {\n  type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);\n}\n\nfunction decoratePipe<T>(type: PipeType<T>, options: UntilDestroyOptions): void {\n  const def = type.ɵpipe;\n  def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);\n}\n\nexport function UntilDestroy(options: UntilDestroyOptions = {}): ClassDecorator {\n  return (type: any) => {\n    if (isPipe(type)) {\n      decoratePipe(type, options);\n    } else {\n      decorateProviderDirectiveOrComponent(type, options);\n    }\n\n    markAsDecorated(type);\n  };\n}\n","import { Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport {\n  DECORATOR_APPLIED,\n  getSymbol,\n  isFunction,\n  createSubjectOnTheInstance,\n  completeSubjectOnTheInstance\n} from './internals';\n\n// This will be provided through Terser global definitions by Angular CLI. This will\n// help to tree-shake away the code unneeded for production bundles.\ndeclare const ngDevMode: boolean;\n\nfunction overrideNonDirectiveInstanceMethod(\n  instance: any,\n  destroyMethodName: string,\n  symbol: symbol\n): void {\n  const originalDestroy = instance[destroyMethodName];\n\n  if (ngDevMode && isFunction(originalDestroy) === false) {\n    throw new Error(\n      `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`\n    );\n  }\n\n  createSubjectOnTheInstance(instance, symbol);\n\n  instance[destroyMethodName] = function() {\n    originalDestroy.apply(this, arguments);\n    completeSubjectOnTheInstance(this, symbol);\n    // We have to re-assign this property back to the original value.\n    // If the `untilDestroyed` operator is called for the same instance\n    // multiple times, then we will be able to get the original\n    // method again and not the patched one.\n    instance[destroyMethodName] = originalDestroy;\n  };\n}\n\nexport function untilDestroyed<T>(instance: T, destroyMethodName?: keyof T) {\n  return <U>(source: Observable<U>) => {\n    const symbol = getSymbol<T>(destroyMethodName);\n\n    // If `destroyMethodName` is passed then the developer applies\n    // this operator to something non-related to Angular DI system\n    if (typeof destroyMethodName === 'string') {\n      overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);\n    } else {\n      ngDevMode && ensureClassIsDecorated(instance);\n      createSubjectOnTheInstance(instance, symbol);\n    }\n\n    return source.pipe(takeUntil<U>((instance as any)[symbol]));\n  };\n}\n\nfunction ensureClassIsDecorated(instance: InstanceType<any>): never | void {\n  const prototype = Object.getPrototypeOf(instance);\n  const missingDecorator = !(DECORATOR_APPLIED in prototype);\n\n  if (missingDecorator) {\n    throw new Error(\n      'untilDestroyed operator cannot be used inside directives or ' +\n        'components or providers that are not decorated with UntilDestroy decorator'\n    );\n  }\n}\n"]}