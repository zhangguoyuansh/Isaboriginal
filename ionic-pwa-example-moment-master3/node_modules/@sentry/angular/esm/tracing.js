import { __assign, __decorate } from "tslib";
import { Directive, Injectable, Input } from '@angular/core';
import { NavigationEnd, NavigationStart } from '@angular/router';
import { getCurrentHub } from '@sentry/browser';
import { logger, stripUrlQueryAndFragment, timestampWithMs } from '@sentry/utils';
import { filter, tap } from 'rxjs/operators';
var instrumentationInitialized;
var stashedStartTransaction;
var stashedStartTransactionOnLocationChange;
/**
 * Creates routing instrumentation for Angular Router.
 */
export function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
    if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad) {
        customStartTransaction({
            name: window.location.pathname,
            op: 'pageload',
        });
    }
}
export var instrumentAngularRouting = routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
export function getActiveTransaction() {
    var currentHub = getCurrentHub();
    if (currentHub) {
        var scope = currentHub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
var TraceService = /** @class */ (function () {
    function TraceService(_router) {
        var _this = this;
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter(function (event) { return event instanceof NavigationStart; }), tap(function (event) {
            if (!instrumentationInitialized) {
                logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            var navigationEvent = event;
            var strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            var activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                });
            }
            if (activeTransaction) {
                _this._routingSpan = activeTransaction.startChild({
                    description: "" + navigationEvent.url,
                    op: "angular.routing",
                    tags: __assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        this.navEnd$ = this._router.events.pipe(filter(function (event) { return event instanceof NavigationEnd; }), tap(function () {
            if (_this._routingSpan) {
                _this._routingSpan.finish();
                delete _this._routingSpan;
            }
        }));
        this.navStart$.subscribe();
        this.navEnd$.subscribe();
    }
    TraceService = __decorate([
        Injectable({ providedIn: 'root' })
    ], TraceService);
    return TraceService;
}());
export { TraceService };
var UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
var TraceDirective = /** @class */ (function () {
    function TraceDirective() {
        this.componentName = UNKNOWN_COMPONENT;
    }
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    TraceDirective.prototype.ngOnInit = function () {
        var activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            this._tracingSpan = activeTransaction.startChild({
                description: "<" + this.componentName + ">",
                op: "angular.initialize",
            });
        }
    };
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    TraceDirective.prototype.ngAfterViewInit = function () {
        if (this._tracingSpan) {
            this._tracingSpan.finish();
        }
    };
    __decorate([
        Input('trace')
    ], TraceDirective.prototype, "componentName", void 0);
    TraceDirective = __decorate([
        Directive({ selector: '[trace]' })
    ], TraceDirective);
    return TraceDirective;
}());
export { TraceDirective };
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClassDecorator() {
    var tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return function (target) {
        var originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                tracingSpan = activeTransaction.startChild({
                    description: "<" + target.name + ">",
                    op: "angular.initialize",
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        var originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (tracingSpan) {
                tracingSpan.finish();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return function (target, propertyKey, descriptor) {
        var originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var now = timestampWithMs();
            var activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                activeTransaction.startChild({
                    description: "<" + target.constructor.name + ">",
                    endTimestamp: now,
                    op: "angular." + String(propertyKey),
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
//# sourceMappingURL=tracing.js.map